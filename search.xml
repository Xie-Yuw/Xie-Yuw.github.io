<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NOI--找最大数序列</title>
      <link href="/2020/01/21/NOI--1.9-10%E6%89%BE%E6%9C%80%E5%A4%A7%E6%95%B0%E5%BA%8F%E5%88%97/"/>
      <url>/2020/01/21/NOI--1.9-10%E6%89%BE%E6%9C%80%E5%A4%A7%E6%95%B0%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h5 id="10-找最大数序列"><a href="#10-找最大数序列" class="headerlink" title="10:找最大数序列"></a>10:找最大数序列</h5><ul><li><p>总时间限制: </p><p>1000ms</p></li><li><p>内存限制: </p><p>65536kB</p></li><li><p>描述</p><p>输入n行，每行不超过100个无符号整数，无符号数不超过4位。请输出最大整数以及最大整数所在的行号（行号从1开始）。如果该数据在多个行中出现，则按从小到大输出相应行号，行号之间以一个逗号分开。 </p></li><li><p>输入</p><p>一行输入一个正整数n（n &lt;= 30）。 之后的n行，每行包含不超过100个无符号整数，整数之间以一个逗号分开。</p></li><li><p>输出</p><p>第一行：最大整数； </p><p>第二行：最大整数所在的行编号，逗号间隔。</p></li><li><p>样例输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1,3,5,23,6,8,14</span><br><span class="line">20,22,13,4,16</span><br><span class="line">23,12,17,22</span><br><span class="line">2,6,10,9,3,6</span><br><span class="line">22,21,20,8,10</span><br><span class="line">22,1,23,6,8,19,23</span><br></pre></td></tr></table></figure></li><li><p>样例输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">23</span><br><span class="line">1,3,6</span><br></pre></td></tr></table></figure></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><p>   注意一下输入格式。</p><h3 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">int a[N];</span><br><span class="line">int b[N];</span><br><span class="line">int d[N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">char c;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">memset(a,0,sizeof(a));</span><br><span class="line">int j&#x3D;0;</span><br><span class="line">    do&#123;</span><br><span class="line">    cin&gt;&gt;a[j++];</span><br><span class="line">&#125;while(getchar()!&#x3D;&#39;\n&#39;);</span><br><span class="line">  sort(a,a+j);</span><br><span class="line">b[i] &#x3D; a[j-1];</span><br><span class="line">&#125;</span><br><span class="line">int max &#x3D; -1;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">if(b[i]&gt;max) max &#x3D; b[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">int k&#x3D;0;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">if(b[i]&#x3D;&#x3D;max) d[k++] &#x3D; i+1;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;d[0];</span><br><span class="line">for(int i&#x3D;1;i&lt;k;i++)&#123;</span><br><span class="line">cout&lt;&lt;&quot;,&quot;&lt;&lt;d[i];</span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI--错误探测</title>
      <link href="/2020/01/21/NOI--%E9%94%99%E8%AF%AF%E6%8E%A2%E6%B5%8B/"/>
      <url>/2020/01/21/NOI--%E9%94%99%E8%AF%AF%E6%8E%A2%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="04-错误探测"><a href="#04-错误探测" class="headerlink" title="04:错误探测"></a>04:错误探测</h2><ul><li><p>总时间限制: </p><p>1000ms</p></li><li><p>内存限制: </p><p>65536kB</p></li><li><p>描述</p><p>给定n*n由0和1组成的矩阵，如果矩阵的每一行和每一列的1的数量都是偶数，则认为符合条件。 你的任务就是检测矩阵是否符合条件，或者在仅改变一个矩阵元素的情况下能否符合条件。 “改变矩阵元素”的操作定义为0变成1或者1变成0。 </p></li><li><p>输入</p><p>输入n + 1行，第1行为矩阵的大小n(0 &lt; n &lt; 100)，以下n行为矩阵的每一行的元素，元素之间以一个空格分开。</p></li><li><p>输出</p><p>如果矩阵符合条件，则输出OK； 如果矩阵仅改变一个矩阵元素就能符合条件，则输出需要改变的元素所在的行号和列号，以一个空格分开。 如果不符合以上两条，输出Corrupt。</p></li><li><p>样例输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">样例输入1</span><br><span class="line">4</span><br><span class="line">1 0 1 0</span><br><span class="line">0 0 0 0</span><br><span class="line">1 1 1 1</span><br><span class="line">0 1 0 1</span><br><span class="line"></span><br><span class="line">样例输入2</span><br><span class="line">4</span><br><span class="line">1 0 1 0</span><br><span class="line">0 0 1 0</span><br><span class="line">1 1 1 1</span><br><span class="line">0 1 0 1</span><br><span class="line"></span><br><span class="line">样例输入3</span><br><span class="line">4</span><br><span class="line">1 0 1 0</span><br><span class="line">0 1 1 0</span><br><span class="line">1 1 1 1</span><br><span class="line">0 1 0 1</span><br></pre></td></tr></table></figure></li><li><p>样例输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">样例输出1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">样例输出2</span><br><span class="line">2 3</span><br><span class="line"></span><br><span class="line">样例输出3</span><br><span class="line">Corrupt</span><br></pre></td></tr></table></figure></li></ul><h3 id="WA代码："><a href="#WA代码：" class="headerlink" title="WA代码："></a>WA代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int M &#x3D; 100+5;</span><br><span class="line">const int N &#x3D; 100+5;</span><br><span class="line"></span><br><span class="line">int a[M][N]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">int c &#x3D; 0,r &#x3D; 0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">a[0][j] &#x3D; (a[0][j]+a[i][j])%2;&#x2F;&#x2F;感觉这个地方还是很巧妙的(get)</span><br><span class="line">a[i][0] &#x3D; (a[i][0]+a[i][j])%2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">if(a[0][j]&#x3D;&#x3D;1) r &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">if(a[i][0]&#x3D;&#x3D;1) c &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">if(c&#x3D;&#x3D;0&amp;&amp;r&#x3D;&#x3D;0) cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl;</span><br><span class="line">else if(c!&#x3D;0&amp;&amp;r!&#x3D;0)cout&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;&quot;Corrupt&quot;&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉思路也没什么问题，写了几组数据测试发现其中一组数据有问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 0 0 0</span><br><span class="line">1 1 0 1</span><br><span class="line">0 0 0 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p>当有多行/列为奇数时，只返回第一组检测的序号。（其实这个时候应该是Corrupt)</p><p>所以应该增加两个变量来记录行或列为奇数的行数/列数。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int M &#x3D; 100+5;</span><br><span class="line">const int N &#x3D; 100+5;</span><br><span class="line"></span><br><span class="line">int a[M][N]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">int c &#x3D; 0,r &#x3D; 0,c1 &#x3D; 0,r1 &#x3D; 0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">a[0][j] &#x3D; (a[0][j]+a[i][j])%2;</span><br><span class="line">a[i][0] &#x3D; (a[i][0]+a[i][j])%2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">if(a[0][j]&#x3D;&#x3D;1)&#123;</span><br><span class="line">r &#x3D; j;</span><br><span class="line">r1++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">if(a[i][0]&#x3D;&#x3D;1)&#123;</span><br><span class="line">c &#x3D; i;</span><br><span class="line">c1++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(c1&#x3D;&#x3D;0&amp;&amp;r1&#x3D;&#x3D;0) cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl;</span><br><span class="line">else if(c1&#x3D;&#x3D;1&amp;&amp;r1&#x3D;&#x3D;1)cout&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;&quot;Corrupt&quot;&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园导航</title>
      <link href="/2020/01/10/%E6%A0%A1%E5%9B%AD%E5%AF%BC%E8%88%AA/"/>
      <url>/2020/01/10/%E6%A0%A1%E5%9B%AD%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<h2 id="校园导航-STD"><a href="#校园导航-STD" class="headerlink" title="校园导航-STD"></a>校园导航-STD</h2><p>这是之前数据结构做的一个图的实验。</p><h4 id="一、题目要求"><a href="#一、题目要求" class="headerlink" title="一、题目要求"></a>一、题目要求</h4><p>图是应用极为广泛的数据结构，也是这门课程的重点。它的特点在于非线性。稀疏矩阵 的十字链表存储结构也是图的一种存储结构，故也把它们归在这次实习中。本 章 实习继续突 出了数据结构加操作的程序设计观点，但根据这两种结构的非线性特点，将 操 作 进一步集中 在遍历操作上，因为遍历操作是其他众多操作的基础。遍历逻辑的（或符号形式的）结构， 访问动作可是任何操作。本 次 实习还希望达到熟悉各种存储结构的特征，以及如何应用树和 图结构解决具体问题（即原理与应用的结合）等目的。 </p><p>图的基本操作 </p><p>[问题描述]  </p><p>分别用邻接矩阵和邻接表实现以下操作：图的创建、遍历、插入、删除、最短路径。</p><p>[基本要求] </p><p>熟悉图的常用存储结构和基本操作</p><h4 id="二、设计思路"><a href="#二、设计思路" class="headerlink" title="二、设计思路"></a>二、设计思路</h4><p>先构造数据</p><p>所有地点:春晖楼 开元楼 图书馆 十栋 基教 学院楼 消社</p><p>任意两个地点的路径长度： </p><p>春晖楼 开元楼 50</p><p>春晖楼 图书馆 300</p><p>春晖楼 基教 400</p><p>开元楼 基教 200</p><p>基教 学院楼 50</p><p>学院楼 图书馆 10</p><p>十栋 开元楼 250</p><p>十栋 消社 20</p><p>消社 基教 100</p><p>增加的地点:</p><p>消社 招待所 700</p><p>学院楼 招待所 450</p><p>构建一个无向网</p><p> 用邻接矩阵来存储任意两个地点的关系。</p><p>图的遍历用DFS递归来输出地点，任意两点间的最短路径用弗洛伊德算法。</p><h4 id="三、代码："><a href="#三、代码：" class="headerlink" title="三、代码："></a>三、代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MaxInt 32767</span><br><span class="line">#define MVNum 100</span><br><span class="line"></span><br><span class="line">typedef string VerTexType;</span><br><span class="line">typedef int ArcType;</span><br><span class="line"></span><br><span class="line">int vis[MVNum]&#x3D;&#123;0&#125;;</span><br><span class="line">int n&#x3D;0;</span><br><span class="line">int Path[MVNum][MVNum];</span><br><span class="line">int D[MVNum][MVNum];</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">VerTexType vexs[MVNum];</span><br><span class="line">ArcType arcs[MVNum][MVNum];</span><br><span class="line">int vexnum,arcnum;</span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line">int LocateVex(AMGraph G,string u)&#123;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)&#123;</span><br><span class="line">if(u&#x3D;&#x3D;G.vexs[i]) &#123;</span><br><span class="line">    return i;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">    else continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Create(AMGraph &amp;G)&#123;</span><br><span class="line">int w;</span><br><span class="line">string v1,v2;</span><br><span class="line">printf(&quot;请输入总地点数和路径数:&quot;);</span><br><span class="line">cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;</span><br><span class="line">printf(&quot;请输入所有地点:\n&quot;);&#x2F;&#x2F;春晖楼 开元楼 图书馆 十栋 基教 学院楼消社 </span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)&#123; </span><br><span class="line">cin&gt;&gt;G.vexs[i];</span><br><span class="line">&#125; </span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)</span><br><span class="line">for(int j&#x3D;1;j&lt;&#x3D;G.vexnum;j++)</span><br><span class="line">    G.arcs[i][j]&#x3D;MaxInt;</span><br><span class="line">for(int k&#x3D;1;k&lt;&#x3D;G.arcnum;k++)&#123;</span><br><span class="line">printf(&quot;请输入两个地点及其路径:&quot;);</span><br><span class="line">    cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;</span><br><span class="line">int m&#x3D;LocateVex(G,v1);</span><br><span class="line">int n&#x3D;LocateVex(G,v2);</span><br><span class="line">G.arcs[m][n]&#x3D;w;</span><br><span class="line">G.arcs[n][m]&#x3D;w;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void Display(AMGraph G,int v)&#123;</span><br><span class="line">if(n&gt;G.vexnum) return;</span><br><span class="line">if(!vis[v])&#123;</span><br><span class="line">vis[v]&#x3D;1;</span><br><span class="line">    cout&lt;&lt;G.vexs[v]&lt;&lt;&quot; &quot;;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)&#123;</span><br><span class="line">    if(G.arcs[v][i]!&#x3D;MaxInt&amp;&amp;vis[i]&#x3D;&#x3D;0) &#123;</span><br><span class="line">    n++;</span><br><span class="line">    Display(G,i);</span><br><span class="line">&#125;</span><br><span class="line">else continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(AMGraph &amp;G)&#123;</span><br><span class="line">int w;</span><br><span class="line">string v1,v2;</span><br><span class="line">printf(&quot;请输入你要增加的地点和路径的数目:&quot;);</span><br><span class="line">int p,q;</span><br><span class="line">cin&gt;&gt;p&gt;&gt;q;</span><br><span class="line">int t&#x3D;G.vexnum;</span><br><span class="line">G.vexnum+&#x3D;p;</span><br><span class="line">G.arcnum+&#x3D;q;</span><br><span class="line">for(int k&#x3D;t+1;k&lt;&#x3D;G.vexnum;k++)&#123;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)</span><br><span class="line">    G.arcs[i][k]&#x3D;MaxInt;</span><br><span class="line">for(int j&#x3D;1;j&lt;&#x3D;G.vexnum;j++)</span><br><span class="line">    G.arcs[k][j]&#x3D;MaxInt;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;请输入增加的地点:&quot;;</span><br><span class="line">for(int i&#x3D;t+1;i&lt;&#x3D;G.vexnum;i++)</span><br><span class="line">cin&gt;&gt;G.vexs[i];</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;q;i++)&#123;</span><br><span class="line">printf(&quot;请输入两个地点及其路径:&quot;);</span><br><span class="line">    cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w;</span><br><span class="line">    int m&#x3D;LocateVex(G,v1);</span><br><span class="line">    int n&#x3D;LocateVex(G,v2);</span><br><span class="line">    G.arcs[m][n]&#x3D;w;</span><br><span class="line">    G.arcs[n][m]&#x3D;w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delete(AMGraph &amp;G)&#123;</span><br><span class="line">int l&#x3D;0;</span><br><span class="line">string u;</span><br><span class="line">cout&lt;&lt;&quot;请输入要删除的地点:&quot;;</span><br><span class="line">cin&gt;&gt;u;</span><br><span class="line">int t&#x3D;LocateVex(G,u);</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)&#123;</span><br><span class="line">if(G.arcs[t][i]!&#x3D;MaxInt) l++;</span><br><span class="line">&#125;</span><br><span class="line">G.arcnum-&#x3D;l;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)&#123;</span><br><span class="line">G.arcs[i][t]&#x3D;MaxInt;</span><br><span class="line">G.arcs[t][i]&#x3D;MaxInt;</span><br><span class="line">&#125;</span><br><span class="line">G.vexs[t]&#x3D;&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Floyd(AMGraph G)</span><br><span class="line">&#123;</span><br><span class="line">int i,j,k;</span><br><span class="line">for (i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)</span><br><span class="line">for (j&#x3D;1;j&lt;&#x3D;G.vexnum;j++)</span><br><span class="line">&#123;</span><br><span class="line">D[i][j] &#x3D; G.arcs[i][j];</span><br><span class="line">if (D[i][j]&lt;MaxInt &amp;&amp; i!&#x3D;j)</span><br><span class="line"> Path[i][j] &#x3D; i;</span><br><span class="line">else Path[i][j] &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line">for(k&#x3D;1;k&lt;&#x3D;G.vexnum;k++)</span><br><span class="line">for(i&#x3D;1;i&lt;&#x3D;G.vexnum;i++)</span><br><span class="line">for(j&#x3D;1;j&lt;&#x3D;G.vexnum;j++)</span><br><span class="line">if(D[i][k]+D[k][j]&lt;D[i][j])</span><br><span class="line">&#123;</span><br><span class="line">D[i][j] &#x3D; D[i][k] + D[k][j];</span><br><span class="line">Path[i][j] &#x3D; Path[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void ShortPath(AMGraph G)</span><br><span class="line">&#123;</span><br><span class="line">string s1,s2;</span><br><span class="line">int vs,ve,x,temp;</span><br><span class="line">cout&lt;&lt;&quot;请输入起点和终点:&quot;;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">vs&#x3D;LocateVex(G,s1);</span><br><span class="line">ve&#x3D;LocateVex(G,s2);</span><br><span class="line">cout&lt;&lt;&quot;最短路径长为：&quot;;</span><br><span class="line">cout&lt;&lt;D[vs][ve]&lt;&lt;endl;</span><br><span class="line">stack&lt;int&gt; sta;</span><br><span class="line">sta.push(ve);</span><br><span class="line">x &#x3D; ve;</span><br><span class="line">while (Path[vs][x]!&#x3D;vs)</span><br><span class="line">&#123;</span><br><span class="line">sta.push(Path[vs][x]);</span><br><span class="line">x &#x3D; Path[vs][x];</span><br><span class="line">&#125;</span><br><span class="line">sta.push(vs);</span><br><span class="line">cout&lt;&lt;&quot;最短路径为: &quot;;</span><br><span class="line">temp &#x3D; sta.top();</span><br><span class="line">sta.pop();</span><br><span class="line">cout&lt;&lt;G.vexs[temp];</span><br><span class="line">while (!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line">temp &#x3D; sta.top();</span><br><span class="line">sta.pop();</span><br><span class="line">cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;G.vexs[temp];</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void menu()&#123;</span><br><span class="line">cout&lt;&lt;&quot;*********************************************************&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;-----------------石家庄铁道大学校园导航------------------&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;*********************************************************&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;*                    1.  图的创建                       *&quot;&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;*                    2.  图的遍历                       *&quot;&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;*                    3.  图的插入                       *&quot;&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;*                    4.  图的删除                       *&quot;&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;*                    5.  最短路径                       *&quot;&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;&quot;*                    0. 返回主界面                      *&quot;&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">AMGraph G;</span><br><span class="line">int k;</span><br><span class="line">int t1,t2,t3;</span><br><span class="line">string v,u;</span><br><span class="line">menu();</span><br><span class="line">while(1)&#123;</span><br><span class="line">cout&lt;&lt;&quot;请选择:&quot;&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line">switch (k)&#123;</span><br><span class="line">case 1:</span><br><span class="line">Create(G);break;</span><br><span class="line">case 2:</span><br><span class="line">        printf(&quot;请输入出发点:&quot;);</span><br><span class="line">        cin&gt;&gt;v;</span><br><span class="line">         cout&lt;&lt;&quot;从出发点开始遍历的路线为:&quot;;</span><br><span class="line">        t1&#x3D;LocateVex(G,v);</span><br><span class="line">          Display(G,t1);</span><br><span class="line">          cout&lt;&lt;endl;</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">    Insert(G);</span><br><span class="line">        printf(&quot;请输入出发点:&quot;);</span><br><span class="line">cin&gt;&gt;u;</span><br><span class="line">cout&lt;&lt;&quot;从出发点开始遍历的路线为:&quot;;</span><br><span class="line">t2&#x3D;LocateVex(G,u);</span><br><span class="line">n&#x3D;0;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">    Display(G,t2);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    break;</span><br><span class="line">    case 4:</span><br><span class="line">    Delete(G);</span><br><span class="line">    printf(&quot;请输入出发点:&quot;);</span><br><span class="line">cin&gt;&gt;u;</span><br><span class="line">cout&lt;&lt;&quot;从出发点开始遍历的路线为:&quot;;</span><br><span class="line">t3&#x3D;LocateVex(G,u);</span><br><span class="line">    n&#x3D;0;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">    Display(G,t3);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    break;</span><br><span class="line">    case 5:</span><br><span class="line">    Floyd(G);</span><br><span class="line">    ShortPath(G);</span><br><span class="line">    break;</span><br><span class="line">    case 0:</span><br><span class="line">    menu();</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、功能测试"><a href="#四、功能测试" class="headerlink" title="四、功能测试"></a>四、功能测试</h4><p><img src="file:///C:/Users/XieYW/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p><img src="file:///C:/Users/XieYW/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--二叉搜索树</title>
      <link href="/2019/12/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2019/12/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-A-Bug’s-Life"><a href="#题目-A-Bug’s-Life" class="headerlink" title="题目 -  A Bug’s Life"></a>题目 -  A Bug’s Life</h2><p><strong>Background</strong><br>Professor Hopper is researching the sexual behavior of a rare species of bugs. He assumes that they feature two different genders and that they only interact with bugs of the opposite gender. In his experiment, individual bugs and their interactions were easy to identify, because numbers were printed on their backs.<br><strong>Problem</strong><br>Given a list of bug interactions, decide whether the experiment supports his assumption of two genders with no homosexual bugs or if it contains some bug interactions that falsify it.</p><p>Input</p><p>The first line of the input contains the number of scenarios. Each scenario starts with one line giving the number of bugs (at least one, and up to 2000) and the number of interactions (up to 1000000) separated by a single space. In the following lines, each interaction is given in the form of two distinct bug numbers separated by a single space. Bugs are numbered consecutively starting from one.</p><p>Output</p><p>The output for every scenario is a line containing “Scenario #i:”, where i is the number of the scenario starting at 1, followed by one line saying either “No suspicious bugs found!” if the experiment is consistent with his assumption about the bugs’ sexual behavior, or “Suspicious bugs found!” if Professor Hopper’s assumption is definitely wrong.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scenario #1:</span><br><span class="line">Suspicious bugs found!</span><br><span class="line"></span><br><span class="line">Scenario #2:</span><br><span class="line">No suspicious bugs found!</span><br></pre></td></tr></table></figure><p>Hint</p><p>Huge input,scanf is recommended.</p><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>t组数据，n个虫子，m组相互喜爱的关系，虫子分为雌雄两种，每个虫子只有一个性别，问是否存在同性恋的虫子。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>与犯罪团伙那个题差不多。</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pre[20010];</span><br><span class="line">int r[20010];&#x2F;&#x2F;&#x2F;r&#x3D;0代表与根节点同性</span><br><span class="line">int Find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    if(pre[x]&#x3D;&#x3D;x)</span><br><span class="line">    &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    t&#x3D;pre[x];</span><br><span class="line">    pre[x]&#x3D;Find(pre[x]);&#x2F;&#x2F;&#x2F;压缩路径</span><br><span class="line">    r[x]&#x3D;(r[x]+r[t]+1)%2;</span><br><span class="line">    return pre[x];</span><br><span class="line">&#125;</span><br><span class="line">void Union(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    x&#x3D;Find(a);</span><br><span class="line">    y&#x3D;Find(b);</span><br><span class="line">    pre[x]&#x3D;y;</span><br><span class="line">    r[x]&#x3D;(r[b]-r[a])%2;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,i,j,k,flag;</span><br><span class="line">    int n,m,a,b;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(k&#x3D;1;k&lt;&#x3D;t;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag&#x3D;0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(i&#x3D;1; i&lt;&#x3D;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            r[i]&#x3D;1;</span><br><span class="line">            pre[i]&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i&#x3D;1; i&lt;&#x3D;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">            if(Find(a)&#x3D;&#x3D;Find(b))</span><br><span class="line">            &#123;</span><br><span class="line">                if(r[a]&#x3D;&#x3D;r[b])&#x2F;&#x2F;&#x2F;同性</span><br><span class="line">                &#123;</span><br><span class="line">                    flag&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Union(a,b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Scenario #%d:\nSuspicious bugs found!\n\n&quot;,k);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Scenario #%d:\nNo suspicious bugs found!\n\n&quot;,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--Farm Irrigation</title>
      <link href="/2019/12/04/Farm%20Irrigation%20/"/>
      <url>/2019/12/04/Farm%20Irrigation%20/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-Farm-Irrigation"><a href="#题目-Farm-Irrigation" class="headerlink" title="题目 -  Farm Irrigation"></a>题目 -  Farm Irrigation</h2><p>Benny has a spacious farm land to irrigate. The farm land is a rectangle, and is divided into a lot of samll squares. Water pipes are placed in these squares. Different square has a different type of pipe. There are 11 types of pipes, which is marked from A to K, as Figure 1 shows.</p><p><img src="https://vj.z180.cn/98438320b6a336844ea7a50507e0c94c?v=1575336868" alt="img"><br>Figure 1</p><p>Benny has a map of his farm, which is an array of marks denoting the distribution of water pipes over the whole farm. For example, if he has a map</p><p>ADC<br>FJK<br>IHE</p><p>then the water pipes are distributed like</p><p><img src="https://vj.z180.cn/c0c0d1bb80698cbbb549ba460e1ce196?v=1575336868" alt="img"><br>Figure 2</p><p>Several wellsprings are found in the center of some squares, so water can flow along the pipes from one square to another. If water flow crosses one square, the whole farm land in this square is irrigated and will have a good harvest in autumn.</p><p>Now Benny wants to know at least how many wellsprings should be found to have the whole farm land irrigated. Can you help him?</p><p>Note: In the above example, at least 3 wellsprings are needed, as those red points in Figure 2 show.</p><p>Input</p><p>There are several test cases! In each test case, the first line contains 2 integers M and N, then M lines follow. In each of these lines, there are N characters, in the range of ‘A’ to ‘K’, denoting the type of water pipe over the corresponding square. A negative M or N denotes the end of input, else you can assume 1 &lt;= M, N &lt;= 50.</p><p>Output</p><p>For each test case, output in one line the least number of wellsprings needed.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">DK</span><br><span class="line">HF</span><br><span class="line"></span><br><span class="line">3 3</span><br><span class="line">ADC</span><br><span class="line">FJK</span><br><span class="line">IHE</span><br><span class="line"></span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>浇灌田地，图中的蓝色的线代表水管，水管能连起来的用一个泉源即可浇灌，问浇灌这片田地用需要多少个泉源。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>求用的源泉数就是求有几个不连通的图，遍历每块田地，只要考虑它和左边和上边的田地是否能并合并就可以了。对于左边和上边哪两块能够合并，由图可知：</p><p>上联通：ABEGHJK<br>下联通：CDEHIJK<br>左联通：ACFGHIK<br>右联通：BDFGIJK</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N&#x3D;52;</span><br><span class="line">char maze[N][N];</span><br><span class="line">int parent[N*N];</span><br><span class="line">void init(int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        parent[i]&#x3D;i;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return parent[x]&#x3D;&#x3D;x?x:find(parent[x]);</span><br><span class="line">&#125;</span><br><span class="line">void unite(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    x&#x3D;find(x);</span><br><span class="line">    y&#x3D;find(y);</span><br><span class="line">    if(x&#x3D;&#x3D;y)</span><br><span class="line">        return;</span><br><span class="line">    parent[x]&#x3D;y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n!&#x3D;-1&amp;&amp;m!&#x3D;-1)</span><br><span class="line">    &#123;</span><br><span class="line">        init(n*m);</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(j-1&gt;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                if((maze[i][j-1]&#x3D;&#x3D;&#39;B&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;D&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;F&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;G&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;I&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;J&#39;||maze[i][j-1]&#x3D;&#x3D;&#39;K&#39;)</span><br><span class="line">                   &amp;&amp;(maze[i][j]&#x3D;&#x3D;&#39;C&#39;||maze[i][j]&#x3D;&#x3D;&#39;F&#39;||maze[i][j]&#x3D;&#x3D;&#39;G&#39;||maze[i][j]&#x3D;&#x3D;&#39;H&#39;||maze[i][j]&#x3D;&#x3D;&#39;I&#39;||maze[i][j]&#x3D;&#x3D;&#39;A&#39;||maze[i][j]&#x3D;&#x3D;&#39;K&#39;))</span><br><span class="line">                    unite((i-1)*m+j-1,(i-1)*m+j);</span><br><span class="line">            &#125;</span><br><span class="line">            if(i-1&gt;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                if((maze[i-1][j]&#x3D;&#x3D;&#39;C&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;D&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;E&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;H&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;I&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;J&#39;||maze[i-1][j]&#x3D;&#x3D;&#39;K&#39;)&amp;&amp;</span><br><span class="line">                   (maze[i][j]&#x3D;&#x3D;&#39;A&#39;||maze[i][j]&#x3D;&#x3D;&#39;B&#39;||maze[i][j]&#x3D;&#x3D;&#39;E&#39;||maze[i][j]&#x3D;&#x3D;&#39;G&#39;||maze[i][j]&#x3D;&#x3D;&#39;H&#39;||maze[i][j]&#x3D;&#x3D;&#39;J&#39;||maze[i][j]&#x3D;&#x3D;&#39;K&#39;))</span><br><span class="line">                    unite((i-1-1)*m+j,(i-1)*m+j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n*m;i++)</span><br><span class="line">            if(parent[i]&#x3D;&#x3D;i)</span><br><span class="line">            num++;</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--Is It A Tree?</title>
      <link href="/2019/12/03/Is%20It%20A%20Tree%20/"/>
      <url>/2019/12/03/Is%20It%20A%20Tree%20/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-Is-It-A-Tree"><a href="#题目-Is-It-A-Tree" class="headerlink" title="题目 -  Is It A Tree?"></a>题目 -  Is It A Tree?</h2><p>A tree is a well-known data structure that is either empty (null, void, nothing) or is a set of one or more nodes connected by directed edges between nodes satisfying the following properties.<br>There is exactly one node, called the root, to which no directed edges point.</p><p>Every node except the root has exactly one edge pointing to it.</p><p>There is a unique sequence of directed edges from the root to each node.</p><p>For example, consider the illustrations below, in which nodes are represented by circles and edges are represented by lines with arrowheads. The first two of these are trees, but the last is not.</p><p><img src="https://vj.z180.cn/30ef78e36a20744a5f03113e493b37bd?v=1574784453" alt="img"> <img src="https://vj.z180.cn/7ea4cdfb5d2f2f534399ffe7a50055bc?v=1574784453" alt="img"> <img src="https://vj.z180.cn/9d5304508ccb31ccef0e0cc34205bd20?v=1574784453" alt="img"></p><p>In this problem you will be given several descriptions of collections of nodes connected by directed edges. For each of these you are to determine if the collection satisfies the definition of a tree or not.</p><p>Input</p><p>The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers; the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero.</p><p>Output</p><p>For each test case display the line <code>Case k is a tree.&quot; or the line</code>Case k is not a tree.”, where k corresponds to the test case number (they are sequentially numbered starting with 1).</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 8 5 3 5 2 6 4</span><br><span class="line">5 6 0 0</span><br><span class="line">8 1 7 3 6 2 8 9 7 5</span><br><span class="line">7 4 7 8 7 6 0 0</span><br><span class="line">3 8 6 8 6 4</span><br><span class="line">5 3 5 6 5 2 0 0</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case 1 is a tree.</span><br><span class="line">Case 2 is a tree.</span><br><span class="line">Case 3 is not a tree.</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>判断给出的数据能否构成一颗树。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>构成一颗有向树的条件:</p><ol><li><p>不能有环</p></li><li><p>只有一个根即只有一个入度为0的点，否则是森林</p></li><li><p>除了根结点之外的其他点的入度为1</p></li><li><p>任意两个点之间都能连通</p><p>然后注意一下空树也算树。</p><p>计算根节点个数，然后除根结点之外其他的入度均要为1，判断是否是森林，即只有一个根节点。</p></li></ol><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAX&#x3D;1e4+10;</span><br><span class="line">int pre[MAX];</span><br><span class="line">int in[MAX];</span><br><span class="line">int vis[MAX];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i&#x3D;1; i&lt;MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i]&#x3D;0;</span><br><span class="line">        in[i]&#x3D;0;</span><br><span class="line">        pre[i]&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(pre[x]&#x3D;&#x3D;x)</span><br><span class="line">    &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return Find(pre[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Union(int root1,int root2)</span><br><span class="line">&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    x&#x3D;Find(root1);</span><br><span class="line">    y&#x3D;Find(root2);</span><br><span class="line">    if(x!&#x3D;y)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[x]&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,root,counts,a,b,flag,ans&#x3D;1;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!&#x3D;EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a&#x3D;&#x3D;-1&amp;&amp;b&#x3D;&#x3D;-1)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a&#x3D;&#x3D;0&amp;&amp;b&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Case %d is a tree.\n&quot;,ans);</span><br><span class="line">            ans++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        vis[a]&#x3D;1;</span><br><span class="line">        vis[b]&#x3D;1;</span><br><span class="line">        in[b]++;</span><br><span class="line">        Union(a,b);</span><br><span class="line">        while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!&#x3D;EOF)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a&#x3D;&#x3D;0&amp;&amp;b&#x3D;&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[a]&#x3D;1;</span><br><span class="line">            vis[b]&#x3D;1;</span><br><span class="line">            in[b]++;</span><br><span class="line">            Union(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        flag&#x3D;1;</span><br><span class="line">        root&#x3D;0;</span><br><span class="line">        counts&#x3D;0;</span><br><span class="line">        for(i&#x3D;1;i&lt;MAX;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(vis[i]&amp;&amp;in[i]&#x3D;&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                root++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(in[i]&gt;&#x3D;2)</span><br><span class="line">            &#123;</span><br><span class="line">                flag&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(vis[i]&amp;&amp;pre[i]&#x3D;&#x3D;i)</span><br><span class="line">            &#123;</span><br><span class="line">                counts++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root!&#x3D;1||counts&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            flag&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Case %d is a tree.\n&quot;,ans);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Case %d is not a tree.\n&quot;,ans);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 带权并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--More is better</title>
      <link href="/2019/12/03/More%20is%20better/"/>
      <url>/2019/12/03/More%20is%20better/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-More-is-better"><a href="#题目-More-is-better" class="headerlink" title="题目 -  More is better"></a>题目 -  More is better</h2><p>Mr Wang wants some boys to help him with a project. Because the project is rather complex, <strong>the more boys come, the better it will be</strong>. Of course there are certain requirements.</p><p>Mr Wang selected a room big enough to hold the boys. The boy who are not been chosen has to leave the room immediately. There are 10000000 boys in the room numbered from 1 to 10000000 at the very beginning. After Mr Wang’s selection any two of them who are still in this room should be friends (direct or indirect), or there is only one boy left. Given all the direct friend-pairs, you should decide the best way.</p><p>Input</p><p>The first line of the input contains an integer n (0 ≤ n ≤ 100 000) - the number of direct friend-pairs. The following n lines each contains a pair of numbers A and B separated by a single space that suggests A and B are direct friends. (A ≠ B, 1 ≤ A, B ≤ 10000000)</p><p>Output</p><p>The output in one line contains exactly one integer equals to the maximum number of boys Mr Wang may keep.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">5 6</span><br><span class="line">1 6</span><br><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">5 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>Hint</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A and B are friends(direct or indirect), B and C are friends(direct or indirect), </span><br><span class="line">then A and C are also friends(indirect).</span><br><span class="line"></span><br><span class="line"> In the first sample &#123;1,2,5,6&#125; is the result.</span><br><span class="line">In the second sample &#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;,&#123;7,8&#125; are four kinds of answers.</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>A和B是朋友（直接或间接），B和C是朋友（直接或间接），<br>那么A和C也是朋友（间接）。</p><p>在第一个样本{1,2,5,6}中是结果。<br>在第二个示例{1,2}，{3,4}，{5,6}，{7,8}中有四种答案。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p><img src="https://i.loli.net/2019/12/03/uWTxo9ieOmXFHUV.jpg" alt="fullsizerender_1_.jpg"></p><p>比上道龙珠题简单的多其实都差不多</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define maxn 110000</span><br><span class="line">int N, sum;</span><br><span class="line">int per[maxn], ran[maxn];</span><br><span class="line"> </span><br><span class="line">void init() &#123;</span><br><span class="line">    sum &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; maxn; ++i)&#123;</span><br><span class="line">        per[i] &#x3D; i;</span><br><span class="line">        ran[i] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    int r &#x3D; x;</span><br><span class="line">    while( r !&#x3D; per[r])</span><br><span class="line">        r &#x3D; per[r];</span><br><span class="line">    per[x] &#x3D; r;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void join (int a, int b)&#123;</span><br><span class="line">    int fa &#x3D; find(a);</span><br><span class="line">    int fb &#x3D; find(b);</span><br><span class="line">    if(fa !&#x3D; fb)&#123;</span><br><span class="line">        per[fa] &#x3D; fb;</span><br><span class="line">        ran[fb] +&#x3D; ran[fa];</span><br><span class="line">        sum &#x3D; max(sum, ran[fb]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()&#123;</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;N) !&#x3D; EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        if(N &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            printf(&quot;1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        while(N--)&#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            join(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 带权并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--小希的迷宫</title>
      <link href="/2019/12/03/%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB/"/>
      <url>/2019/12/03/%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-小希的迷宫"><a href="#题目-小希的迷宫" class="headerlink" title="题目 -  小希的迷宫"></a>题目 -  小希的迷宫</h2><p>上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。<br><img src="https://vj.z180.cn/ce3d27d9f95d7ac87d47240232e2e0ba?v=1575349768" alt="img"></p><p>Input</p><p>输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。<br>整个文件以两个-1结尾。</p><p>Output</p><p>对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6 8  5 3  5 2  6 4</span><br><span class="line">5 6  0 0</span><br><span class="line"></span><br><span class="line">8 1  7 3  6 2  8 9  7 5</span><br><span class="line">7 4  7 8  7 6  0 0</span><br><span class="line"></span><br><span class="line">3 8  6 8  6 4</span><br><span class="line">5 3  5 6  5 2  0 0</span><br><span class="line"></span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>判断该图是不是连通并且无环的。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>用并查集来判断是否是连通的。</p><p>如果父节点相同，则有环。</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N &#x3D; 1e5+10;</span><br><span class="line">int par[N];</span><br><span class="line">bool vis[N];</span><br><span class="line"></span><br><span class="line">int Find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(par[x] &#x3D;&#x3D; x) return x;</span><br><span class="line">    return par[x] &#x3D; Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line">bool unite(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    x &#x3D; Find(x);</span><br><span class="line">    y &#x3D; Find(y);</span><br><span class="line">    if(x !&#x3D; y) &#123;</span><br><span class="line">        par[x] &#x3D; y; return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b)) &#123;</span><br><span class="line">        if(a&#x3D;&#x3D;-1 &amp;&amp; b&#x3D;&#x3D;-1) break;</span><br><span class="line">        if(a&#x3D;&#x3D;0 &amp;&amp; b&#x3D;&#x3D;0) &#123;</span><br><span class="line">            printf(&quot;Yes\n&quot;);          </span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i &#x3D; 0; i &lt;&#x3D; N; i++) par[i] &#x3D; i;</span><br><span class="line">        unite(a,b);</span><br><span class="line">        vis[a] &#x3D; vis[b] &#x3D; true;</span><br><span class="line">        bool flag &#x3D; true;</span><br><span class="line">        while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b) &amp;&amp; a) &#123;</span><br><span class="line">            bool ans &#x3D; unite(a,b);</span><br><span class="line">            vis[a] &#x3D; vis[b] &#x3D; true;</span><br><span class="line">            if(!ans) flag &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">            if(vis[i] &amp;&amp; par[i]&#x3D;&#x3D;i) k++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(k &gt; 1) flag &#x3D; false;</span><br><span class="line">        if(flag) printf(&quot;Yes\n&quot;);</span><br><span class="line">        else printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--Dragon Balls</title>
      <link href="/2019/12/02/Dragon%20Balls/"/>
      <url>/2019/12/02/Dragon%20Balls/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-Dragon-Balls"><a href="#题目-Dragon-Balls" class="headerlink" title="题目 -  Dragon Balls"></a>题目 -  Dragon Balls</h2><p>Five hundred years later, the number of dragon balls will increase unexpectedly, so it’s too difficult for Monkey King(WuKong) to gather all of the dragon balls together.<br><img src="https://vj.z180.cn/4a6544a4139251ff34655ebaaf261a73?v=1574761495" alt="img"><br>His country has N cities and there are exactly N dragon balls in the world. At first, for the ith dragon ball, the sacred dragon will puts it in the ith city. Through long years, some cities’ dragon ball(s) would be transported to other cities. To save physical strength WuKong plans to take Flying Nimbus Cloud, a magical flying cloud to gather dragon balls.<br>Every time WuKong will collect the information of one dragon ball, he will ask you the information of that ball. You must tell him which city the ball is located and how many dragon balls are there in that city, you also need to tell him how many times the ball has been transported so far.</p><p>Input</p><p>The first line of the input is a single positive integer T(0 &lt; T &lt;= 100).<br>For each case, the first line contains two integers: N and Q (2 &lt; N &lt;= 10000 , 2 &lt; Q &lt;= 10000).<br>Each of the following Q lines contains either a fact or a question as the follow format:<br>  T A B : All the dragon balls which are in the same city with A have been transported to the city the Bth ball in. You can assume that the two cities are different.<br>  Q A : WuKong want to know X (the id of the city Ath ball is in), Y (the count of balls in Xth city) and Z (the tranporting times of the Ath ball). (1 &lt;= A, B &lt;= N)</p><p>Output</p><p>For each test case, output the test case number formated as sample output. Then for each query, output a line with three integers X Y Z saparated by a blank space.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">T 1 2</span><br><span class="line">T 3 2</span><br><span class="line">Q 2</span><br><span class="line">3 4</span><br><span class="line">T 1 2</span><br><span class="line">Q 1</span><br><span class="line">T 1 3</span><br><span class="line">Q 1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">2 3 0</span><br><span class="line">Case 2:</span><br><span class="line">2 2 1</span><br><span class="line">3 3 2</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>初始时，有n个龙珠，编号从1到n，分别对应的放在编号从1到n的城市中。现在有两种操作：</p><p>T A B，表示把A球所在城市全部的龙珠全部转移到B城市。（第一次时，因为A球所在的城市只有一个球，所以只移动1个，如果有多个，则全部移动）。</p><p>Q A，表示查询A。要求得到的信息分别是：A现在所在的城市，A所在城市的龙珠数目，A转移到该城市移动的次数（如果没有移动就输出0）</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p><img src="https://i.loli.net/2019/12/03/Q8VHUBfMD6KWbcu.jpg" alt="fullsizerender.jpg"></p><p>qwq嫌弃..这个字也太丑了！！</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn&#x3D;1e5+10;</span><br><span class="line">int f[maxn];</span><br><span class="line">int sum[maxn];</span><br><span class="line">int Move[maxn];</span><br><span class="line">int n,m;</span><br><span class="line">void init_set()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;1; i&lt;&#x3D;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]&#x3D;i;</span><br><span class="line">        sum[i]&#x3D;1;</span><br><span class="line">        Move[i]&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int find_set(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!&#x3D;f[x])</span><br><span class="line">    &#123;</span><br><span class="line">        int t&#x3D;f[x];</span><br><span class="line">        f[x]&#x3D;find_set(f[x]);</span><br><span class="line">        Move[x]+&#x3D;Move[t];</span><br><span class="line">        return f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">void unit_set(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    x&#x3D;find_set(x);</span><br><span class="line">    y&#x3D;find_set(y);</span><br><span class="line">    if(x&#x3D;&#x3D;y)return;</span><br><span class="line">    f[x]&#x3D;y;</span><br><span class="line">    sum[y]+&#x3D;sum[x];</span><br><span class="line">    Move[x]++;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    int l&#x3D;0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        l++;</span><br><span class="line">        printf(&quot;Case %d:\n&quot;,l);</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        init_set();</span><br><span class="line">        for(int i&#x3D;0; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            char s[6];</span><br><span class="line">            scanf(&quot;%s&quot;,s);</span><br><span class="line">            if(s[0]&#x3D;&#x3D;&#39;T&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                int x,y;</span><br><span class="line">                scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">                unit_set(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(s[0]&#x3D;&#x3D;&#39;Q&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                int x;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">                int ans&#x3D;find_set(x);</span><br><span class="line">                printf(&quot;%d %d %d\n&quot;,ans,sum[ans],Move[x]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 带权并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--Find them, Catch them</title>
      <link href="/2019/12/01/Find%20them,%20Catch%20them/"/>
      <url>/2019/12/01/Find%20them,%20Catch%20them/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-Find-them-Catch-them"><a href="#题目-Find-them-Catch-them" class="headerlink" title="题目 - Find them, Catch them"></a>题目 - Find them, Catch them</h2><p>The police office in Tadu City decides to say ends to the chaos, as launch actions to root up the TWO gangs in the city, Gang Dragon and Gang Snake. However, the police first needs to identify which gang a criminal belongs to. The present question is, given two criminals; do they belong to a same clan? You must give your judgment based on incomplete information. (Since the gangsters are always acting secretly.)</p><p>Assume N (N &lt;= 10^5) criminals are currently in Tadu City, numbered from 1 to N. And of course, at least one of them belongs to Gang Dragon, and the same for Gang Snake. You will be given M (M &lt;= 10^5) messages in sequence, which are in the following two kinds:</p><p>\1. D [a] [b]<br>where [a] and [b] are the numbers of two criminals, and they belong to different gangs.</p><p>\2. A [a] [b]<br>where [a] and [b] are the numbers of two criminals. This requires you to decide whether a and b belong to a same gang.</p><p>Input</p><p>The first line of the input contains a single integer T (1 &lt;= T &lt;= 20), the number of test cases. Then T cases follow. Each test case begins with a line with two integers N and M, followed by M lines each containing one message as described above.</p><p>Output</p><p>For each message “A [a] [b]” in each case, your program should give the judgment based on the information got before. The answers might be one of “In the same gang.”, “In different gangs.” and “Not sure yet.”</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 5</span><br><span class="line">A 1 2</span><br><span class="line">D 1 2</span><br><span class="line">A 1 2</span><br><span class="line">D 2 4</span><br><span class="line">A 1 4</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Not sure yet.</span><br><span class="line">In different gangs.</span><br><span class="line">In the same gang</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>在一个城市里有两种不同的犯罪团伙。首先输入T表示有T组测试，然后输入N和M，表示有N个罪犯（编号从1到N）而且接下来有M个操作。操作分为两种：</p><p>1.D a b，表示编号为a和b的两个罪犯属于不同的犯罪团伙；</p><p>2.A a b，表示询问编号为a和b的两个罪犯是否是同一个犯罪团伙或者不确定。</p><p>对于每一个A操作，根据题意都要有相应的回答（输出）。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>一道标准的关系型并查集题。普通的并查集是给几个同类的元素，而关系型并查集是给不同类的元素，然后求各个元素之间的关系。对于这种题目,我们不仅需要开一个pre[]存父节点,还需要开一个r[]关系数组,来记录其和父亲的关系,r[]=0表示属于同一个帮派,r[]=1，表示不属于同一个帮派，初始化都为同一个帮派。一旦输入x和y不属于同一个帮派就将x和y连通同时更新r[]，一旦输入A，如果find（x）!=find（y）,说明还没输入它们的关系,所以不确定;如果find（x）==find(y） 由于r[]数组表示的是该节点和父节点的关系,两个节点又属于同一个节点,所以如果r[x]==r[y]则属于同一个帮派,否则不属于;<br>处理方法:<br>1、在利用find函数不断寻找根节点的过程中需要不断更新r[],举个例子:因为我们在利用find函数寻找根节点时有路径压缩,所以我们需要推导出<br>子节点、父节点、和爷爷节点三者之间的关系:<br>如果 子节点和父节点关系为r1，父节点和爷爷节点关系为r2，那么孙子节点和爷爷节点的关系为（r1+r2）%2;(两种情况所以对2去模)<br>证明:<br>我们可以列出所有的可能情况<br>     （a, b）  (b, c)  (a, c)  (r1+r2)%2<br>           0            0       0        0<br>           0            1       1        1<br>           1            0       1        1<br>           1            1       0        0<br>PS:我个人一开始对为什么子父节点之间的关系会为同一个帮派感到困惑,因为题目中给出的都是不同帮派的,其实仔细一想并不是,我们在合并连通<br>过程中存在着路径压缩,将孙子节点变为了儿子节点通过上面的关系式就有可能出现相同的情况了;<br>2、在用join函数就行连通是也需要及时更新r[],我们还是通过推导得出关系式,<br>假设我们f1为x1的根节点,f2为x2的根节点,我们现在要将f1合并到f2上去, 推导关系式为 r[f1]=(r[x1]+r[x2]+1)%2;<br>证明:<br>我们还是罗列出一些情况: 首先需要明确一点的,我们需要合并 x1和x2以为他们两个不是同一个帮派的,所以有x1和x2的关系为1<br>（x1, f1） (x2, f2)  (x1, x2) (f1,f2)_<br>       0                0          1         1<br>       0                1          1         0<br>       1                0          1         0<br>       1                1          1         1</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 100010 </span><br><span class="line">int pre[N];</span><br><span class="line">int r[N];</span><br><span class="line">int n,m;</span><br><span class="line">void init() </span><br><span class="line">&#123;</span><br><span class="line">     for (int i&#x3D;1;i&lt;&#x3D;n;i++)       </span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]&#x3D;i;</span><br><span class="line">              r[i]&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">int find(int x) </span><br><span class="line">&#123;</span><br><span class="line">      if(x&#x3D;&#x3D;pre[x])      return x;</span><br><span class="line">         int tmp&#x3D;pre[x];</span><br><span class="line">         pre[x]&#x3D;find(pre[x]);</span><br><span class="line">         r[x]&#x3D;(r[x]+r[tmp])%2;</span><br><span class="line">         return pre[x];</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">void join(int x1,int x2) </span><br><span class="line">&#123;</span><br><span class="line">        int f1&#x3D;find(x1);</span><br><span class="line">        int f2&#x3D;find(x2);</span><br><span class="line">        if(f1!&#x3D;f2)     </span><br><span class="line">    &#123;</span><br><span class="line">         pre[f1]&#x3D;f2;</span><br><span class="line">         r[f1]&#x3D;(r[x1]+r[x2]+1)%2;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">        return ;</span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">      int t,i;</span><br><span class="line">        char c;</span><br><span class="line">    int a,b;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">        while(t--)     </span><br><span class="line">    &#123;</span><br><span class="line">         scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">               init();</span><br><span class="line">               getchar();</span><br><span class="line">               for (i&#x3D;1;i&lt;&#x3D;m;i++)         </span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%c %d %d&quot;,&amp;c,&amp;a,&amp;b);</span><br><span class="line">            getchar();</span><br><span class="line">            if(c&#x3D;&#x3D;&#39;D&#39;) </span><br><span class="line">            &#123;</span><br><span class="line">                     join(a,b);</span><br><span class="line">                   </span><br><span class="line">            &#125; else </span><br><span class="line">            &#123;</span><br><span class="line">                   if(find(a)!&#x3D;find(b))       </span><br><span class="line">                   printf(&quot;Not sure yet.n&quot;);      </span><br><span class="line">                   else      </span><br><span class="line">                   &#123;   </span><br><span class="line">                   if(r[a]&#x3D;&#x3D;r[b])          </span><br><span class="line">                   printf(&quot;In the same gang.n&quot;); </span><br><span class="line">                   else          </span><br><span class="line">                   printf(&quot;In different gangs.\n&quot;);  </span><br><span class="line">                   &#125;     </span><br><span class="line">                   &#125;   </span><br><span class="line">                   &#125;      </span><br><span class="line">                   &#125;   </span><br><span class="line">                   return 0; </span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 带权并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--The Suspects</title>
      <link href="/2019/12/01/The%20Suspects/"/>
      <url>/2019/12/01/The%20Suspects/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-The-Suspect"><a href="#题目-The-Suspect" class="headerlink" title="题目 - The Suspect"></a>题目 - The Suspect</h2><p>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.</p><p>Input</p><p>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.</p><p>Output</p><p>For each case, output the number of suspects in one line.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">100 4</span><br><span class="line">2 1 2</span><br><span class="line">5 10 13 11 12 14</span><br><span class="line">2 0 1</span><br><span class="line">2 99 2</span><br><span class="line">200 2</span><br><span class="line">1 5</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>给定学生总数和学生分组，0号学生得了SARS 问有SARS的嫌疑的有多少人，和0同一组即为有嫌疑。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p><img src="https://i.loli.net/2019/12/01/YL9WZF4M5rSVCeU.png" alt="TIM图片20191201094621.png"></p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[30005] ,group[30005], num[30005];</span><br><span class="line">int findgroup(int x)&#x2F;&#x2F;查询每个学生的组长是谁。</span><br><span class="line">&#123;</span><br><span class="line">    if(x&#x3D;&#x3D;group[x]) return x;</span><br><span class="line">    else return findgroup(group[x]);</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#x2F;&#x2F;在同一组的学生需要把组长选定。</span><br><span class="line">&#123;</span><br><span class="line">    int grox&#x3D;findgroup(x);</span><br><span class="line">    int groy&#x3D;findgroup(y);</span><br><span class="line">    if(grox!&#x3D;groy)</span><br><span class="line">    &#123;</span><br><span class="line">        group[grox]&#x3D;groy;</span><br><span class="line">        num[groy]+&#x3D;num[grox];&#x2F;&#x2F;每一次合并，都需要吧集合中的元素个数加进去。</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,k;</span><br><span class="line">    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0&amp;&amp;m&#x3D;&#x3D;0)</span><br><span class="line">            break;</span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++) &#x2F;&#x2F;开个数组，给数组赋值，即自己自成一组并为组长。</span><br><span class="line">        &#123;</span><br><span class="line">            group[i]&#x3D;i;</span><br><span class="line">            num[i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        while(m--)&#x2F;&#x2F;共有m个样例。</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d &quot;,&amp;k);</span><br><span class="line">            for(int i&#x3D;0; i&lt;k; i++)</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">            for(int i&#x3D;0; i&lt;k-1; i++)&#x2F;&#x2F;把在同一组的几个学生合并在一起。</span><br><span class="line">                join(a[i],a[i+1]);&#x2F;&#x2F;如果组长不同，便把组长选定。</span><br><span class="line">        &#125;</span><br><span class="line">        int t&#x3D;findgroup(0);&#x2F;&#x2F;找到生病的0号学生的组长。</span><br><span class="line">        printf(&quot;%d\n&quot;,num[t]);</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--Wireless Network</title>
      <link href="/2019/12/01/Wireless%20Network/"/>
      <url>/2019/12/01/Wireless%20Network/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-Wireless-Network"><a href="#题目-Wireless-Network" class="headerlink" title="题目 - Wireless Network"></a>题目 - Wireless Network</h2><p>An earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The computers are repaired one by one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded as the intermediary of the communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B.</p><p>In the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations.</p><p>Input</p><p>The first line contains two integers N and d (1 &lt;= N &lt;= 1001, 0 &lt;= d &lt;= 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next N lines, each contains two integers xi, yi (0 &lt;= xi, yi &lt;= 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following two formats:<br>\1. “O p” (1 &lt;= p &lt;= N), which means repairing computer p.<br>\2. “S p q” (1 &lt;= p, q &lt;= N), which means testing whether computer p and q can communicate.</p><p>The input will not exceed 300000 lines.</p><p>Output</p><p>For each Testing operation, print “SUCCESS” if the two computers can communicate, or “FAIL” if not.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">4 1</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 3</span><br><span class="line">0 4</span><br><span class="line">O 1</span><br><span class="line">O 2</span><br><span class="line">O 4</span><br><span class="line">S 1 4</span><br><span class="line">O 3</span><br><span class="line">S 1 4</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FAIL</span><br><span class="line">SUCCESS</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>给定学生总数和学生分组，0号学生得了SARS 问有SARS的嫌疑的有多少人，和0同一组即为有嫌疑。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p><img src="C:%5CUsers%5CXieYW%5CDesktop%5CTIM%E5%9B%BE%E7%89%8720191201094621.png" alt="TIM图片20191201094621"></p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[30005] ,group[30005], num[30005];</span><br><span class="line">int findgroup(int x)&#x2F;&#x2F;查询每个学生的组长是谁。</span><br><span class="line">&#123;</span><br><span class="line">    if(x&#x3D;&#x3D;group[x]) return x;</span><br><span class="line">    else return findgroup(group[x]);</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)&#x2F;&#x2F;在同一组的学生需要把组长选定。</span><br><span class="line">&#123;</span><br><span class="line">    int grox&#x3D;findgroup(x);</span><br><span class="line">    int groy&#x3D;findgroup(y);</span><br><span class="line">    if(grox!&#x3D;groy)</span><br><span class="line">    &#123;</span><br><span class="line">        group[grox]&#x3D;groy;</span><br><span class="line">        num[groy]+&#x3D;num[grox];&#x2F;&#x2F;每一次合并，都需要吧集合中的元素个数加进去。</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,k;</span><br><span class="line">    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0&amp;&amp;m&#x3D;&#x3D;0)</span><br><span class="line">            break;</span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++) &#x2F;&#x2F;开个数组，给数组赋值，即自己自成一组并为组长。</span><br><span class="line">        &#123;</span><br><span class="line">            group[i]&#x3D;i;</span><br><span class="line">            num[i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        while(m--)&#x2F;&#x2F;共有m个样例。</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d &quot;,&amp;k);</span><br><span class="line">            for(int i&#x3D;0; i&lt;k; i++)</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">            for(int i&#x3D;0; i&lt;k-1; i++)&#x2F;&#x2F;把在同一组的几个学生合并在一起。</span><br><span class="line">                join(a[i],a[i+1]);&#x2F;&#x2F;如果组长不同，便把组长选定。</span><br><span class="line">        &#125;</span><br><span class="line">        int t&#x3D;findgroup(0);&#x2F;&#x2F;找到生病的0号学生的组长。</span><br><span class="line">        printf(&quot;%d\n&quot;,num[t]);</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 带权并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--A Bug&#39;s Life</title>
      <link href="/2019/12/01/A%20Bug&#39;s%20Life/"/>
      <url>/2019/12/01/A%20Bug&#39;s%20Life/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-A-Bug’s-Life"><a href="#题目-A-Bug’s-Life" class="headerlink" title="题目 -  A Bug’s Life"></a>题目 -  A Bug’s Life</h2><p><strong>Background</strong><br>Professor Hopper is researching the sexual behavior of a rare species of bugs. He assumes that they feature two different genders and that they only interact with bugs of the opposite gender. In his experiment, individual bugs and their interactions were easy to identify, because numbers were printed on their backs.<br><strong>Problem</strong><br>Given a list of bug interactions, decide whether the experiment supports his assumption of two genders with no homosexual bugs or if it contains some bug interactions that falsify it.</p><p>Input</p><p>The first line of the input contains the number of scenarios. Each scenario starts with one line giving the number of bugs (at least one, and up to 2000) and the number of interactions (up to 1000000) separated by a single space. In the following lines, each interaction is given in the form of two distinct bug numbers separated by a single space. Bugs are numbered consecutively starting from one.</p><p>Output</p><p>The output for every scenario is a line containing “Scenario #i:”, where i is the number of the scenario starting at 1, followed by one line saying either “No suspicious bugs found!” if the experiment is consistent with his assumption about the bugs’ sexual behavior, or “Suspicious bugs found!” if Professor Hopper’s assumption is definitely wrong.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scenario #1:</span><br><span class="line">Suspicious bugs found!</span><br><span class="line"></span><br><span class="line">Scenario #2:</span><br><span class="line">No suspicious bugs found!</span><br></pre></td></tr></table></figure><p>Hint</p><p>Huge input,scanf is recommended.</p><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>t组数据，n个虫子，m组相互喜爱的关系，虫子分为雌雄两种，每个虫子只有一个性别，问是否存在同性恋的虫子。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>与犯罪团伙那个题差不多。</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pre[20010];</span><br><span class="line">int r[20010];&#x2F;&#x2F;&#x2F;r&#x3D;0代表与根节点同性</span><br><span class="line">int Find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    if(pre[x]&#x3D;&#x3D;x)</span><br><span class="line">    &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    t&#x3D;pre[x];</span><br><span class="line">    pre[x]&#x3D;Find(pre[x]);&#x2F;&#x2F;&#x2F;压缩路径</span><br><span class="line">    r[x]&#x3D;(r[x]+r[t]+1)%2;</span><br><span class="line">    return pre[x];</span><br><span class="line">&#125;</span><br><span class="line">void Union(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    x&#x3D;Find(a);</span><br><span class="line">    y&#x3D;Find(b);</span><br><span class="line">    pre[x]&#x3D;y;</span><br><span class="line">    r[x]&#x3D;(r[b]-r[a])%2;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,i,j,k,flag;</span><br><span class="line">    int n,m,a,b;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(k&#x3D;1;k&lt;&#x3D;t;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag&#x3D;0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(i&#x3D;1; i&lt;&#x3D;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            r[i]&#x3D;1;</span><br><span class="line">            pre[i]&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i&#x3D;1; i&lt;&#x3D;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">            if(Find(a)&#x3D;&#x3D;Find(b))</span><br><span class="line">            &#123;</span><br><span class="line">                if(r[a]&#x3D;&#x3D;r[b])&#x2F;&#x2F;&#x2F;同性</span><br><span class="line">                &#123;</span><br><span class="line">                    flag&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Union(a,b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Scenario #%d:\nSuspicious bugs found!\n\n&quot;,k);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Scenario #%d:\nNo suspicious bugs found!\n\n&quot;,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--食物链</title>
      <link href="/2019/12/01/%E9%A3%9F%E7%89%A9%E9%93%BE/"/>
      <url>/2019/12/01/%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-食物链"><a href="#题目-食物链" class="headerlink" title="题目 -  食物链"></a>题目 -  食物链</h2><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。<br>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>第一种说法是”1 X Y”，表示X和Y是同类。<br>第二种说法是”2 X Y”，表示X吃Y。<br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>1） 当前的话与前面的某些真的话冲突，就是假话；<br>2） 当前的话中X或Y比N大，就是假话；<br>3） 当前的话表示X吃X，就是假话。<br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。</p><p>Input</p><p>第一行是两个整数N和K，以一个空格分隔。<br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。<br>若D=1，则表示X和Y是同类。<br>若D=2，则表示X吃Y。</p><p>Output</p><p>只有一个整数，表示假话的数目。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1 </span><br><span class="line">2 1 2</span><br><span class="line">2 2 3 </span><br><span class="line">2 3 3 </span><br><span class="line">1 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>( ﹁ ﹁ ) 中文题目读得懂..</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>确定关系的放在同一颗树里，另加一个r[]数组来记录每个结点和它的根节点的关系，r[]=0,代表同类;r[]=1,代表被父亲吃了；r[]=2，代表它吃了父亲。</p><p>满足其中一个为假话:</p><p>1） 当前的话与前面的某些真的话冲突，就是假话；<br>2） 当前的话中X或Y比N大，就是假话；<br>3） 当前的话表示X吃X，就是假话。</p><p>题目要判断假话的个数,输入的值为d,x,y。</p><p>首先可以判断x或者y是否大于N，如果大于，则假话数加一。</p><p>其次，通过find()函数找x，y的根结点判断是否相同。（相同说明有确定关系)</p><ul><li>相同，则合并x，y所在的树，因为y被x吃所以将y树并在x树上，再更新y树对新的父结点的r[]值即r[fy]。</li></ul><p>下面我们来分析一下r[fy]等于多少:</p><p>fy-&gt;fx=fy-&gt;y+y-&gt;x+x-&gt;fx=3-r[y]+d-1+r[x]</p><p>(因为d==1时，y-&gt;x=0;d==2时,y-&gt;x=1,所以y-&gt;x=1）</p><p>合并时:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void unite(int x,int y,int d)</span><br><span class="line">&#123;</span><br><span class="line">    int fx&#x3D;find(x);</span><br><span class="line">    int fy&#x3D;find(y);</span><br><span class="line">    p[fy]&#x3D;fx;</span><br><span class="line">    r[fy]&#x3D;(r[x]-r[y]+3+(d-1))%3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过d的值来判断是否说谎。</p><p>如果d==1,r[x]!=r[y]，说谎数加一。</p><p>如果d==2,r[x]+1)%3!=r[y],说谎数加一。</p><p>查找:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&#x3D;&#x3D;p[x]) return x;</span><br><span class="line">    int t&#x3D;p[x];</span><br><span class="line">    p[x]&#x3D;find(p[x]);</span><br><span class="line">    r[x]&#x3D;(r[x]+r[t])%3;</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不相同，则两个结点建立关系。</li></ul><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50000+10;</span><br><span class="line">int p[maxn]; </span><br><span class="line">int r[maxn];</span><br><span class="line">void set(int n) </span><br><span class="line">&#123;</span><br><span class="line">    for(int x &#x3D; 1; x &lt;&#x3D; n; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[x] &#x3D; x; </span><br><span class="line">        r[x] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int find(int x) </span><br><span class="line">&#123;</span><br><span class="line">    if(x &#x3D;&#x3D; p[x]) return x;</span><br><span class="line"> </span><br><span class="line">    int t &#x3D; p[x];</span><br><span class="line">    p[x] &#x3D; find(p[x]);</span><br><span class="line">    r[x] &#x3D; (r[x]+r[t])%3; </span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void unite(int x, int y, int d)</span><br><span class="line">&#123;</span><br><span class="line">    int fx &#x3D; find(x);</span><br><span class="line">    int fy &#x3D; find(y);</span><br><span class="line"> </span><br><span class="line">    p[fy] &#x3D; fx; </span><br><span class="line">    r[fy] &#x3D; (r[x]-r[y]+3+(d-1))%3; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    set(n);</span><br><span class="line"> </span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    int d, x, y;</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;d, &amp;x, &amp;y);</span><br><span class="line"> </span><br><span class="line">        if(x &gt; n || y &gt; n || (d &#x3D;&#x3D; 2 &amp;&amp; x &#x3D;&#x3D; y)) ans++; </span><br><span class="line"> </span><br><span class="line">        else if(find(x) &#x3D;&#x3D; find(y)) </span><br><span class="line">        &#123;</span><br><span class="line">            if(d &#x3D;&#x3D; 1 &amp;&amp; r[x] !&#x3D; r[y]) ans++; </span><br><span class="line">            if(d &#x3D;&#x3D; 2 &amp;&amp; (r[x]+1)%3 !&#x3D; r[y]) ans++; </span><br><span class="line">        &#125;</span><br><span class="line">        else unite(x, y, d); </span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 带权并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--今年暑假不AC</title>
      <link href="/2019/12/01/%E4%BB%8A%E5%B9%B4%E6%9A%91%E5%81%87%E4%B8%8DAC/"/>
      <url>/2019/12/01/%E4%BB%8A%E5%B9%B4%E6%9A%91%E5%81%87%E4%B8%8DAC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-今年暑假不AC"><a href="#题目-今年暑假不AC" class="headerlink" title="题目 -  今年暑假不AC"></a>题目 -  今年暑假不AC</h2><p>“今年暑假不AC？”<br>“是的。”<br>“那你干什么呢？”<br>“看世界杯呀，笨蛋！”<br>“@#$%^&amp;*%…”</p><p>确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。<br>作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）</p><p>Input</p><p>输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。</p><p>Output</p><p>对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">1 3</span><br><span class="line">3 4</span><br><span class="line">0 7</span><br><span class="line">3 8</span><br><span class="line">15 19</span><br><span class="line">15 20</span><br><span class="line">10 15</span><br><span class="line">8 18</span><br><span class="line">6 12</span><br><span class="line">5 10</span><br><span class="line">4 14</span><br><span class="line">2 9</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>中文题，意思很清楚了。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>要求看最多的节目，有三种思考方式:看最早开始时间（这个没用，不能保证两个节目不重合），用时最少的节目（这个也没用)，只有当上一个节目结束时才能进行下一个节目，所以下一个节目能否进行取决于上一个活动的最晚结束时间。因此，将每个时间的最晚结束时间先排序（由小到大），然后只要保证下一个活动的最早开始时间大于等于上一个活动的最晚结束时间就能顺利进行。由于要等所有的数据输入之后才能做出判断所以先用一个数组来存储最早开始时间和最晚结束时间（用结构体数组来存储)。</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int start,end;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(const node&amp;a,const node&amp;b)&#123;</span><br><span class="line">return a.end&lt;b.end;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n)&#123;</span><br><span class="line">node time[99];</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">int endtime &#x3D; -1; </span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;time[i].start&gt;&gt;time[i].end;</span><br><span class="line">&#125;</span><br><span class="line">sort(time,time+n,cmp);</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">if(time[i].start&gt;&#x3D;endtime) </span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">endtime &#x3D; time[i].end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1988 Cube Stacking</title>
      <link href="/2019/11/29/Cube%20Stacking/"/>
      <url>/2019/11/29/Cube%20Stacking/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-Cube-Stacking"><a href="#题目-Cube-Stacking" class="headerlink" title="题目 - Cube Stacking"></a>题目 - Cube Stacking</h2><p>  Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:<br>moves and counts.<br>* In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.<br>* In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.</p><p>Write a program that can verify the results of the game.</p><p>Input</p><p>* Line 1: A single integer, P</p><p>* Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.</p><p>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.</p><p>Output</p><p>Print the output from each of the count operations in the same order as the input file.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">M 1 6</span><br><span class="line">C 1</span><br><span class="line">M 2 4</span><br><span class="line">M 2 6</span><br><span class="line">C 3</span><br><span class="line">C 4</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h4><p><strong>有若干个方块，经p次操作后，在x方块下面的方块有多少个，M操作—&gt;将包含x方块的堆移到含y的堆上，C操作—&gt;输出x方块下方方块的数目。</strong></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li><p>x方块下方方块数目=总数目-上方方块数目</p></li><li><p>如图所示</p><p>![`T0X6L_@KNGWGV_IFP__4YG.png](<a href="https://i.loli.net/2019/12/01/5NJpSi28VfPBb4U.png" target="_blank" rel="noopener">https://i.loli.net/2019/12/01/5NJpSi28VfPBb4U.png</a>)</p></li></ul><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f[30010],cnt[30010],up[30010];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int y;</span><br><span class="line">    if(x!&#x3D;f[x])</span><br><span class="line">    &#123;</span><br><span class="line">       y&#x3D;f[x];</span><br><span class="line">       f[x]&#x3D;find(y);</span><br><span class="line">       up[x]+&#x3D;up[y];</span><br><span class="line">    &#125;</span><br><span class="line">    return f[x];</span><br><span class="line">&#125;</span><br><span class="line">void Union(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int px&#x3D;find(x);</span><br><span class="line">    int py&#x3D;find(y);</span><br><span class="line">    if(px&#x3D;&#x3D;py)</span><br><span class="line">    return ;</span><br><span class="line">    front[py]&#x3D;px;</span><br><span class="line">    up[py]&#x3D;cnt[px];</span><br><span class="line">    cnt[px]+&#x3D;cnt[py];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int p,i,j,x,y;</span><br><span class="line">    char a;</span><br><span class="line">    cin&gt;&gt;p;</span><br><span class="line">    for(i&#x3D;1;i&lt;&#x3D;30000;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]&#x3D;i;</span><br><span class="line">        cnt[i]&#x3D;1;</span><br><span class="line">        up[i]&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        if(a&#x3D;&#x3D;&#39;M&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">            Union(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            int px&#x3D;find(x);</span><br><span class="line">            printf(&quot;%d\n&quot;,cnt[px]-up[x]-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还有一种思路是把父亲放在下面，过程与上图类似，只不过是倒过来了。</li></ul><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f[30010],cnt[30010],dis[30010];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int y;</span><br><span class="line">    if(x!&#x3D;f[x])</span><br><span class="line">    &#123;</span><br><span class="line">        y&#x3D;f[x];</span><br><span class="line">        f[x]&#x3D;find(f[x]);</span><br><span class="line">        dis[x]+&#x3D;dis[y];</span><br><span class="line">    &#125;</span><br><span class="line">    return f[x];</span><br><span class="line">&#125;</span><br><span class="line">void Union(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int px&#x3D;find(x);</span><br><span class="line">    int py&#x3D;find(y);</span><br><span class="line">    if(px&#x3D;&#x3D;py)</span><br><span class="line">    return ;</span><br><span class="line">    f[px]&#x3D;py;</span><br><span class="line">    dis[px]+&#x3D;cnt[py];</span><br><span class="line">    cnt[py]+&#x3D;cnt[px];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int p,i,j,x,y;</span><br><span class="line">    char a;</span><br><span class="line">    cin&gt;&gt;p;</span><br><span class="line">    for(i&#x3D;1;i&lt;&#x3D;30000;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        front[i]&#x3D;i;</span><br><span class="line">        dis[i]&#x3D;0;</span><br><span class="line">        cnt[i]&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        if(a&#x3D;&#x3D;&#39;M&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">            Union(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            find(x);</span><br><span class="line">            cout&lt;&lt;dis[x]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 带权并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集专题</title>
      <link href="/2019/11/27/ACM%E8%AE%AD%E7%BB%83--%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2019/11/27/ACM%E8%AE%AD%E7%BB%83--%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><strong>算法理解</strong></p><p>​        并查集是一种树型的数据结构，用于处理一些不交集的合并和查询问题。联合-查找算法(union-find algorithm)定义了两个用于此数据结构的操作。</p><ul><li><strong>Union</strong>:  将两个子集合并成同一个集合，根据父节点的引用像根行进直到树根。</li><li><strong>Find</strong>:  确定元素属于哪一个集合，方法就是不断的向上查找找到它的根节点，确定两个元素是否在同一个子集，将两棵树合并到一起，这通过将一颗树的根连接到另一棵树的根。</li></ul><p>​       在并查集树中，每个集合的代表即是集合的根节点。</p><p><strong>初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    pre[i]&#x3D;i;&#x2F;&#x2F;使每一个点的父结点都指向自己</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;递归</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(pre[x]&#x3D;&#x3D;x) return x;</span><br><span class="line">    return find(find(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;非递归</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r&#x3D;x;&#x2F;&#x2F;将当前位置记录</span><br><span class="line">    while(pre(r)!&#x3D;r) &#x2F;&#x2F;如果不是根节点</span><br><span class="line">    r&#x3D;pre(r);&#x2F;&#x2F;继续向上查找，r的值更新为其父结点</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样写数据量大的时候会爆，下面来看路径压缩优化：</p><p><strong>路径压缩优化</strong></p><p>将某个根结点下的所有子结点都指向该根结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int r&#x3D;x;</span><br><span class="line">    while(pre[r]!&#x3D;r)</span><br><span class="line">    &#123;</span><br><span class="line">        r&#x3D;pre[r];</span><br><span class="line">    &#125;</span><br><span class="line">    int i&#x3D;x;&#x2F;&#x2F;记录当前点</span><br><span class="line">    int j;&#x2F;&#x2F;记录i的上家</span><br><span class="line">    while(i!&#x3D;r)&#x2F;&#x2F;若当前点不是根结点</span><br><span class="line">    &#123;</span><br><span class="line">        j&#x3D;pre[i];&#x2F;&#x2F;记录上家</span><br><span class="line">        pre[i]&#x3D;r;&#x2F;&#x2F;使当前点直接指向根节点</span><br><span class="line">        i&#x3D;j;&#x2F;&#x2F;当前点移动到上家</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void merge(int x,int y)    &#x2F;&#x2F;合并集合 </span><br><span class="line">&#123;</span><br><span class="line">    int t1&#x3D;find(x);    &#x2F;&#x2F;找到x和y的根结点 </span><br><span class="line">    int t2&#x3D;find(y);</span><br><span class="line">    if(t1!&#x3D;t2)    pre[t1]&#x3D;t2; &#x2F;&#x2F;所在集合不同，将其中一个作为另一个集合的子集(根结点一样)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><h4 id="A-How-Many-Tables"><a href="#A-How-Many-Tables" class="headerlink" title="A - How Many Tables"></a><strong>A - How Many Tables</strong></h4><p>Today is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.</p><p>One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.</p><p>For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.</p><p>Input</p><p>The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases.</p><p>Output</p><p>For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">5 1</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1050;</span><br><span class="line">int s[maxn];</span><br><span class="line">void init_set()&#123;</span><br><span class="line">for(int i&#x3D;1;i&lt;maxn;i++)</span><br><span class="line">    s[i]&#x3D;i;</span><br><span class="line">&#125;</span><br><span class="line">int find_set(int x)&#123;</span><br><span class="line">return x&#x3D;&#x3D;s[x]?x:find_set(s[x]);</span><br><span class="line">&#125;</span><br><span class="line">void union_set(int x,int y)&#123;</span><br><span class="line">x&#x3D;find_set(x);</span><br><span class="line">y&#x3D;find_set(y);</span><br><span class="line">if(x!&#x3D;y) s[x]&#x3D;s[y];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t,m,n,x,y;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">init_set();</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">union_set(x,y);</span><br><span class="line">&#125;</span><br><span class="line">int ans&#x3D;0;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">if(s[i]&#x3D;&#x3D;i) ans++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-Ubiquitous-Religions"><a href="#B-Ubiquitous-Religions" class="headerlink" title="B - Ubiquitous Religions"></a>B - Ubiquitous Religions</h4><p>There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in.</p><p>You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.</p><p>Input</p><p>The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0.</p><p>Output</p><p>For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">1 6</span><br><span class="line">1 7</span><br><span class="line">1 8</span><br><span class="line">1 9</span><br><span class="line">1 10</span><br><span class="line">10 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">4 8</span><br><span class="line">5 8</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 7</span><br></pre></td></tr></table></figure><p>Hint</p><p>Huge input, scanf is recommended.</p><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h4><p>有 <img src="https://private.codecogs.com/gif.latex?n" alt="n"> 个学生，编号 <img src="https://private.codecogs.com/gif.latex?1%5Csim%20n" alt="1\sim n">，每个学生最多有 <img src="https://private.codecogs.com/gif.latex?1" alt="1"> 个宗教信仰，输入 <img src="https://private.codecogs.com/gif.latex?m" alt="m"> 组数据，每组数据包含 <img src="https://private.codecogs.com/gif.latex?a%2Cb" alt="a,b">，表示同学 <img src="https://private.codecogs.com/gif.latex?a" alt="a"> 和同学 <img src="https://private.codecogs.com/gif.latex?b" alt="b"> 有相同的信仰，求在 <img src="https://private.codecogs.com/gif.latex?n" alt="n"> 名学生中最多存在多少种不同的宗教信仰。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>与A题一样。</p><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码:"></a>AC代码:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50000+5;</span><br><span class="line">int s[maxn];</span><br><span class="line">int height[maxn];</span><br><span class="line">void init_set()&#123;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;maxn;i++)&#123;</span><br><span class="line">s[i]&#x3D;i;</span><br><span class="line">height[i]&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int find_set(int x)&#123;</span><br><span class="line">return x &#x3D;&#x3D; s[x] ? x:find_set(s[x]);</span><br><span class="line">&#125;</span><br><span class="line">void union_set(int x,int y)&#123;</span><br><span class="line">x &#x3D; find_set(x);</span><br><span class="line">y &#x3D; find_set(y);</span><br><span class="line">if(height[x] &#x3D;&#x3D; height[y])&#123;</span><br><span class="line">height[x] &#x3D; height[x] + 1;</span><br><span class="line">s[y] &#x3D; x;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(height[x] &lt; height [y]) s[x] &#x3D; y;</span><br><span class="line">else s[y] &#x3D; x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">int t,n,m,x,y;</span><br><span class="line">int k&#x3D;1;</span><br><span class="line">while(cin &gt;&gt; n &gt;&gt;m &amp;&amp;m&amp;&amp;n)&#123;</span><br><span class="line">init_set();</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">cin &gt;&gt;x&gt;&gt;y;</span><br><span class="line">union_set(x,y);</span><br><span class="line">&#125;</span><br><span class="line">int ans &#x3D; 0;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">if(s[i] &#x3D;&#x3D; i)</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;Case &quot;&lt;&lt;k++&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VJudge--全排列</title>
      <link href="/2019/11/21/%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2019/11/21/%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>​     排列与组合是常用的数学方法。<br>先给一个正整数 ( 1 &lt; = n &lt; = 10 )<br>例如n＝3，所有组合,并且按字典序输出：<br>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1 </p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入一个整数n(  1&lt;=n&lt;=10)</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出所有全排列</p><p>每个全排列一行，相邻两个数用空格隔开（最后一个数后面没有空格）</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>解析：</p><p>​      1.首先我们考虑1号盒子，我们约定每到一个盒子面前都按数字递增的顺序摆放扑克牌。于是把1号扑克牌放到1号盒子中。<br>​      2.接着考虑2号盒子，现在我们手里剩下2号和3号扑克牌，于是我们可以把2号扑克牌放入2号盒子中。于是在3号盒子只剩一种可能性，我们继           续把3号扑克放入3号盒子。此时产生了一种排列——{1,2,3</p><p>​      3.接着我们收回3号盒子中的3号扑克牌，尝试一种新的可能，此时发现别无他选。于是选择回到2号盒子收回2号扑克。</p><p>​      4.在2号盒子中我们放入3号扑克，于是自然而然的在3号盒子中只能放入2号扑克。此时产生另一种排列——{1,3,2}；</p><p>​      5.重复以上步骤就能得到数字{123}的全排列。</p><p> 1、现在我们用C语言代码描述往每个小盒子中放入所有可能扑克牌的步骤：</p><p>for(int i = 1; i &lt;= n; i++){ a[step] = i; //将i号扑克牌放入第step个盒子中 }</p><p>2、a是一个装入了所有小盒子的数组，变量step表示当前正处于第step号小盒子。i则表示扑克牌的序号。现在我们需要考虑另外一个问题，则如果一张扑克牌已经被放入别的盒子中，则不能再被放入当前盒子。</p><p>因此需要一个book数组标记哪些牌已经被使用。此时我们完善上述代码。</p><p>for(int i = 1; i &lt;= n; i++){ if(book[i] == 0){ a[step] = i; //将i号扑克牌放入第step个盒子中 book[i] = 1; // 置1表示第i号扑克牌不在手中 } }</p><p>现在对于step号盒子已经处理完，那么我们要考虑step+1号盒子。第step+1个的盒子的处理方式与第step个盒子的处理方式完全一样。因此，我们可以对上述操作做一个封装。</p><p>void dfs(int step)</p><p>{ </p><p>//step表示当前要处理的盒子</p><p> for(int i = 1; i &lt;= n; i++)</p><p>{ </p><p>if(book[i] == 0)</p><p>{ a[step] = i; //将i号扑克牌放入第step个盒子中</p><p> book[i] = 1; // 置1表示第i号扑克牌不在手中 </p><p>} } }</p><p>于是我们重新回想文章开头阐述的放置扑克牌的思路：</p><p>我们在当前盒子放置完第i个扑克牌之后，便立即处理下一个盒子。于是：</p><p>void dfs(int step)</p><p>{ </p><p>//step表示当前要处理的盒子 </p><p>for(int i = 1; i &lt;= n; i++)</p><p>{ </p><p>if(book[i] == 0)</p><p>{ </p><p>a[step] = i; //将i号扑克牌放入第step个盒子中 </p><p>book[i] = 1; // 置1表示第i号扑克牌不在手中</p><p> dfs(step+1); //递归调用</p><p> book[i] = 0; // 非常重要，收回该盒子中的扑克牌才能进行下一次尝试。</p><p> } } }</p><p>需要注意到的是，我们需要收回每一次尝试的扑克牌i，才能进行下一次尝试。</p><p>现在需要考虑最后一个问题，那就是什么时候得到一个满足要求的排列，也就是考虑终止条件。这里很容易得到，当我们处理完成第n个盒子的时候，就已经得到一个符合要求的排列了。加上终止条件的代码如下：</p><p>void dfs(int step){</p><p> //step表示当前要处理的盒子 </p><p>if(step == n+1)</p><p>{ </p><p>//输出排列 </p><p>for(i = 1; i &lt;= n; i++) printf(“%d”, a[i]);</p><p> printf(“\n”); return; } </p><p>for(int i = 1; i &lt;= n; i++)</p><p>{ </p><p>if(book[i] == 0)</p><p>{ a[step] = i; </p><p>//将i号扑克牌放入第step个盒子中 </p><p>book[i] = 1; </p><p>// 置1表示第i号扑克牌不在手中 </p><p>dfs(step+1); //递归调用</p><p> book[i] = 0; // 非常重要，收回该盒子中的扑克牌才能进行下一次尝试。 } } }</p><p>现在深度优先搜索（DFS）的基本模型展现在我们眼前。</p><p>其核心在于，在当前步骤要把每一种可能性都尝试一遍（使用for循环），解决完当前步骤后进入下一步。而下一步的解决方式完全等同于当前步骤的解决方法。于是可以总结出DFS的基本模型：</p><p>void dfs(int step){ </p><p><em>判断结束边界</em> 尝试每一种可能 </p><p>for(i = 1; i &lt;= n; i++)</p><p>{ </p><p>尝试下一步 dfs(step + 1);</p><p> } return; }</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深搜递归入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU2030--汉字统计</title>
      <link href="/2019/11/18/%E6%B1%89%E5%AD%97%E7%BB%9F%E8%AE%A1/"/>
      <url>/2019/11/18/%E6%B1%89%E5%AD%97%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>汉字统计</p><p>Problem Description</p><p>统计给定文本文件中汉字的个数。</p><p>Input</p><p>输入文件首先包含一个整数n，表示测试实例的个数，然后是n段文本。</p><p>Output</p><p>对于每一段文本，输出其中的汉字的个数，每个测试实例的输出占一行。</p><p>[Hint:]从汉字机内码的特点考虑~</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">WaHaHa! WaHaHa! 今年过节不说话要说只说普通话WaHaHa! WaHaHa!</span><br><span class="line">马上就要期末考试了Are you ready?</span><br></pre></td></tr></table></figure><p> Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">14</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>Author</p><p>lcy</p><p> Source</p><p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=+C%D3%EF%D1%D4%B3%CC%D0%F2%C9%E8%BC%C6%C1%B7%CF%B0%A3%A8%CE%E5%A3%A9&source=1&searchmode=source" target="_blank" rel="noopener">C语言程序设计练习（五）</a></p><p> Recommend</p><p>lcy   |   We have carefully selected several similar problems for you:  <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2031" target="_blank" rel="noopener">2031</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2032" target="_blank" rel="noopener">2032</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2026" target="_blank" rel="noopener">2026</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2027" target="_blank" rel="noopener">2027</a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2024" target="_blank" rel="noopener">2024</a> </p><hr><p>思路：从汉字机内码的角度考虑，汉子机内码都是占两个字节且每个字节的第一个二进制位都是0,就是都为负数，除2就是汉字个数。</p><hr><p> AC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    getchar();</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int m&#x3D;0;</span><br><span class="line">    while((c&#x3D;getchar())!&#x3D;&#39;\n&#39;)</span><br><span class="line">    if(c&lt;0) m++;</span><br><span class="line">    cout&lt;&lt;m&#x2F;2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HDU第一阶段 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见OJ错误</title>
      <link href="/2019/11/18/OJ%E9%94%99%E8%AF%AF/"/>
      <url>/2019/11/18/OJ%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h5 id="hello-world-">&emsp;&emsp;记录一下我在做题过程中WA的原因。<a id="more"></a></h5>​       float换为double，如hdu2003。大家在做题的时候还是养成用double的习惯，因为一般由于用double而不是float导致超内存和超时而引起的问题很少出现。<p>​       scanf()输入时注意用getchar（）存取换行符。</p><p>​       在输入数据时要考虑输入的数据是否满足条件，如hdu2007 。输入两个正整数x，y并不默认表示x&lt;y,在写代码时要判断一下是否x&lt;y，不然就WA掉了。而且要考虑到可能会出现的情况以及读清楚题意，如hdu2054。判断A和B是否相等，但题目并没有告诉A,B是什么类型，由于我默认认为它是整型，于是它又WA了。(我寻思这个题怎么这么简单…)。</p><p>​        一定要注意审题，如果题目没有说是整数就当double型以免WA掉例如hdu2039。</p><p>一些其他的错误:</p><p>Presentation Error：注意一下最后一行有没有空格，在循环体中判断一下是不是最后一行。</p><p>Output Limit Exceeded：输入时用scanf()没有加!=EOF，陷入死循环(用cin可)。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OJ错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL和基本数据结构</title>
      <link href="/2019/11/03/STL%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/11/03/STL%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h5 id="hello-world-">&emsp;&emsp;STL(Standard Template Library)是C++的标准模板库熟练掌握它们在很多题目中能极大地简化编程，需要完全掌握。<a id="more"></a></h5><h5 id="hello-world-">&emsp;&emsp;STL包括容器(container)、迭代器(iterator)、空间配置器(allocator)、配接器(adapter)、算法(algorithm)、仿函数(functor)6个部分。<!-- more --></h5><h4 id="hello-world-">&emsp; 容器</h4><h5 id="hello-world-">&emsp; 1.顺序式容器</h5>vector ：动态数组，从末尾能快速插入与删除，直接访问任何元素。<p>list ：双链表，从任何地方快速插入和删除。</p><p>deque ：双向队列，从前面或后面快速插入与删除，直接访问任何元素。</p><p>queue：队列，先进先出。</p><p>priority_queue：优先队列，最高优先级元素总是第一个出列。</p><p>stack：栈，后进先出。</p><h5 id="hello-world-">&emsp; 2.关联式容器</h5>set：集合，快速查找，不允许重复值。<p>map：一对多映射，基于关键字快速查找，不允许重复值。</p><p>multiset：快速查找，允许重复值。</p><p>multimap：一对多映射，基于关键字快速查找，允许重复值。</p><h6 id="hello-world-">&emsp; vector</h6>hdu 4841 “圆桌问题”<p>[<a href="https://vjudge.net/contest/337673#problem/A]" target="_blank" rel="noopener">https://vjudge.net/contest/337673#problem/A]</a>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">vector &lt;int&gt; table;</span><br><span class="line">int m,n;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">table.clear();</span><br><span class="line">for(int i&#x3D;0;i&lt;2*n;i++) table.push_back(i);</span><br><span class="line">int pos &#x3D; 0;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">pos &#x3D; (pos+m-1)%table.size();</span><br><span class="line">table.erase(table.begin()+pos);</span><br><span class="line">&#125;</span><br><span class="line">int j&#x3D;0;</span><br><span class="line">for(int i&#x3D;0;i&lt;2*n;i++)&#123;</span><br><span class="line">if(!(i%50)&amp;&amp;i) cout&lt;&lt;endl;</span><br><span class="line">if(j&lt;table.size()&amp;&amp;i&#x3D;&#x3D;table[j])&#123;</span><br><span class="line">j++;</span><br><span class="line">cout&lt;&lt;&quot;G&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else cout&lt;&lt;&quot;B&quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="hello-world-">&emsp; stack</h6>hdu 1062 ”Text Reverse“<p>[<a href="https://vjudge.net/contest/337673#problem/B]" target="_blank" rel="noopener">https://vjudge.net/contest/337673#problem/B]</a>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">char ch;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">ch &#x3D; getchar();</span><br><span class="line">while(n--)&#123;</span><br><span class="line">stack&lt;char&gt;s;</span><br><span class="line">while(true)&#123;</span><br><span class="line">ch &#x3D; getchar();</span><br><span class="line">if(ch&#x3D;&#x3D;&#39;\n&#39;||ch&#x3D;&#x3D;&#39; &#39;||ch&#x3D;&#x3D;EOF)&#123;</span><br><span class="line">while(!s.empty())&#123;</span><br><span class="line">printf(&quot;%c&quot;,s.top());</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">   if(ch&#x3D;&#x3D;&#39;\n&#39;||ch&#x3D;&#x3D;EOF) break;</span><br><span class="line">printf(&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">else s.push(ch);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hdu 1237 “简单计算器”</p><p>[<a href="https://vjudge.net/contest/337673#problem/C]" target="_blank" rel="noopener">https://vjudge.net/contest/337673#problem/C]</a>: </p><p>思路：(太懒了8想写了..)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int P(char c)</span><br><span class="line">&#123;</span><br><span class="line">    if (c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39;) return 1;</span><br><span class="line">    return 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Ans(double x, double y, char c)</span><br><span class="line">&#123;</span><br><span class="line">    if (c &#x3D;&#x3D; &#39;+&#39;) return x + y;</span><br><span class="line">    if (c &#x3D;&#x3D; &#39;-&#39;) return x - y;</span><br><span class="line">    if (c &#x3D;&#x3D; &#39;*&#39;)return x*y;</span><br><span class="line">    return x &#x2F; y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        char c &#x3D; getchar();</span><br><span class="line">        if (c&#x3D;&#x3D;&#39;\n&#39;&amp;&amp;n &#x3D;&#x3D; 0)break;</span><br><span class="line">        stack&lt;char&gt; op;</span><br><span class="line">        stack&lt;double&gt;num;</span><br><span class="line">        num.push(n);</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%c %d&quot;, &amp;c, &amp;n);</span><br><span class="line">            char k &#x3D; getchar();</span><br><span class="line">            while (!op.empty()&amp;&amp;P(c)&lt;&#x3D;P(op.top()))</span><br><span class="line">            &#123;</span><br><span class="line">                char t &#x3D; op.top();</span><br><span class="line">                op.pop();</span><br><span class="line">                double y &#x3D; num.top();</span><br><span class="line">                num.pop();</span><br><span class="line">                double x &#x3D; num.top();</span><br><span class="line">                num.pop();</span><br><span class="line">                double ans &#x3D; Ans(x, y, t);</span><br><span class="line">                num.push(ans);</span><br><span class="line">            &#125;</span><br><span class="line">            op.push(c);</span><br><span class="line">            num.push(n);</span><br><span class="line">            if (k &#x3D;&#x3D; &#39;\n&#39;)break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        while (!op.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            char t &#x3D; op.top();</span><br><span class="line">            op.pop();</span><br><span class="line">            double y &#x3D; num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            double x &#x3D; num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            double ans &#x3D; Ans(x, y, t);</span><br><span class="line">            num.push(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.2f\n&quot;, num.top());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="hello-world-">&emsp; Queue</h6>hdu 1702 ”ACboy needs your help again！“<p>[<a href="https://vjudge.net/contest/337673#problem/D]" target="_blank" rel="noopener">https://vjudge.net/contest/337673#problem/D]</a>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,temp,n;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    string str1,str;</span><br><span class="line">    queue&lt;int&gt;Q;</span><br><span class="line">    stack&lt;int&gt;S;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;str;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    if(str&#x3D;&#x3D;&quot;FIFO&quot;)&#123;</span><br><span class="line">    cin&gt;&gt;str1;</span><br><span class="line">    if(str1 &#x3D;&#x3D; &quot;IN&quot;)&#123;</span><br><span class="line">    cin&gt;&gt;temp;</span><br><span class="line">    Q.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">if(str1 &#x3D;&#x3D; &quot;OUT&quot;)&#123;</span><br><span class="line">if(Q.empty()) cout&lt;&lt;&quot;None&quot;&lt;&lt;endl;</span><br><span class="line">else &#123;</span><br><span class="line">cout&lt;&lt;Q.front()&lt;&lt;endl;</span><br><span class="line">Q.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cin&gt;&gt;str1;</span><br><span class="line">if(str1 &#x3D;&#x3D; &quot;IN&quot;)&#123;</span><br><span class="line">cin&gt;&gt;temp;</span><br><span class="line">S.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">if(str1 &#x3D;&#x3D; &quot;OUT&quot;)&#123;</span><br><span class="line">if(S.empty()) cout&lt;&lt;&quot;None&quot;&lt;&lt;endl;</span><br><span class="line">else &#123;</span><br><span class="line">cout&lt;&lt;S.top()&lt;&lt;endl;</span><br><span class="line">S.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hdu 1873 ”看病要排队“</p><p>[<a href="https://vjudge.net/contest/337673#problem/E]" target="_blank" rel="noopener">https://vjudge.net/contest/337673#problem/E]</a>: </p><p>注意队列中存放结构体的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int n,id;</span><br><span class="line">&#125;st;</span><br><span class="line">bool operator &lt; (const node&amp;a,const node&amp;b)&#123;</span><br><span class="line">if(a.n&#x3D;&#x3D;b.n) return a.id&gt;b.id;</span><br><span class="line">else return a.n&lt;b.n;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">priority_queue&lt;node&gt; q[4];</span><br><span class="line">char s[10];</span><br><span class="line">int a,b;</span><br><span class="line">int k&#x3D;1;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%s %d&quot;,s,&amp;a);</span><br><span class="line">if(strcmp(s,&quot;IN&quot;)&#x3D;&#x3D;0)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;b);</span><br><span class="line">st.n&#x3D;b;</span><br><span class="line">st.id&#x3D;k++;</span><br><span class="line">q[a].push(st); </span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if(!q[a].empty())&#123;</span><br><span class="line">st &#x3D; q[a].top();</span><br><span class="line">q[a].pop();</span><br><span class="line">printf(&quot;%d\n&quot;,st.id);</span><br><span class="line">&#125;</span><br><span class="line">else printf(&quot;EMPTY\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="hello-world-">&emsp; list</h6>hdu 1276 ”士兵队列训练问题“<p>[<a href="https://vjudge.net/contest/337673#problem/F]" target="_blank" rel="noopener">https://vjudge.net/contest/337673#problem/F]</a>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t,n;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">int k &#x3D; 2;</span><br><span class="line">list&lt;int&gt;mylist;</span><br><span class="line">list&lt;int&gt;::iterator it;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">mylist.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">while(mylist.size()&gt;3)&#123;</span><br><span class="line">int num &#x3D; 1;</span><br><span class="line">for(it &#x3D; mylist.begin();it !&#x3D; mylist.end();)&#123;</span><br><span class="line">if(num++%k&#x3D;&#x3D;0) it &#x3D; mylist.erase(it);</span><br><span class="line">else it++;</span><br><span class="line">&#125;</span><br><span class="line">k&#x3D;&#x3D;2?k&#x3D;3:k&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line">for(it &#x3D;mylist.begin();it!&#x3D;mylist.end();it++)&#123;</span><br><span class="line">if(it!&#x3D;mylist.begin()) cout&lt;&lt;&quot; &quot;;</span><br><span class="line">cout&lt;&lt;*it;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="hello-world-">&emsp; set</h6>hdu 2094 “产生冠军”<p>[<a href="https://vjudge.net/contest/337673#problem/G]" target="_blank" rel="noopener">https://vjudge.net/contest/337673#problem/G]</a>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;string&gt;A,B;</span><br><span class="line">string s1,s2;</span><br><span class="line">int n;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n)&#123;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">A.insert(s1);</span><br><span class="line">A.insert(s2);</span><br><span class="line">B.insert(s2);</span><br><span class="line">&#125;</span><br><span class="line">if(A.size()-B.size()&#x3D;&#x3D;1) &#123;</span><br><span class="line">cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;</span><br><span class="line">A.clear();</span><br><span class="line">B.clear();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="hello-world-">&emsp; map</h6>hdu 2648 “Shopping”<p>[<a href="https://vjudge.net/contest/337673#problem/H]" target="_blank" rel="noopener">https://vjudge.net/contest/337673#problem/H]</a>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n,m,p;</span><br><span class="line">map&lt;string,int&gt;shop;</span><br><span class="line">while(cin&gt;&gt;n)&#123;</span><br><span class="line">string s;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">while(m--)&#123;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;p&gt;&gt;s;</span><br><span class="line">shop[s]+&#x3D;p;</span><br><span class="line">&#125;</span><br><span class="line">int rank&#x3D; 1;</span><br><span class="line">map&lt;string,int&gt;::iterator it;</span><br><span class="line">for(it &#x3D; shop.begin();it!&#x3D;shop.end();it++)&#123;</span><br><span class="line">if(it-&gt;second&gt;shop[&quot;memory&quot;])&#123;</span><br><span class="line">rank++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;rank&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">shop.clear();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="hello-world-">&emsp; next_permutation</h6>hdu 1027 "Ignatius and the Princess II"<p>[<a href="https://vjudge.net/contest/337673#problem/I]" target="_blank" rel="noopener">https://vjudge.net/contest/337673#problem/I]</a>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[1001];</span><br><span class="line">    int n,m;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++) a[i]&#x3D;i;</span><br><span class="line">    int b &#x3D; 1;</span><br><span class="line">    do&#123;</span><br><span class="line">    if(m&#x3D;&#x3D;b) break;</span><br><span class="line">    b++;</span><br><span class="line">&#125;while(next_permutation(a+1,a+1+n));</span><br><span class="line">for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;a[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hdu 1716 “排列2”</p><p>[<a href="https://vjudge.net/contest/337673#problem/J]" target="_blank" rel="noopener">https://vjudge.net/contest/337673#problem/J]</a>: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5],tag&#x3D;0;</span><br><span class="line">    while(scanf(&quot;%d%d%d%d&quot;,&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3]))</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[0]&#x3D;&#x3D;0 &amp;&amp; a[1]&#x3D;&#x3D;0 &amp;&amp; a[2]&#x3D;&#x3D;0 &amp;&amp; a[3]&#x3D;&#x3D;0)</span><br><span class="line">            break;  </span><br><span class="line">        if(tag)</span><br><span class="line">            printf(&quot;\n&quot;);  </span><br><span class="line">        tag&#x3D;1;</span><br><span class="line">        int flag&#x3D;1,tmp;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[0]&#x3D;&#x3D;0) </span><br><span class="line">                continue;</span><br><span class="line">            if(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;%d%d%d%d&quot;,a[0],a[1],a[2],a[3]);</span><br><span class="line">                flag&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tmp&#x3D;&#x3D;a[0])</span><br><span class="line">                printf(&quot; %d%d%d%d&quot;,a[0],a[1],a[2],a[3]);</span><br><span class="line">            else</span><br><span class="line">                printf(&quot;\n%d%d%d%d&quot;,a[0],a[1],a[2],a[3]);</span><br><span class="line">            tmp&#x3D;a[0];  </span><br><span class="line">        &#125;while(next_permutation(a,a+4));</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-快慢指针</title>
      <link href="/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
      <url>/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h5 id="hello-world-">&emsp;&emsp;快慢指针中的快慢指的是移动的步长，即每次向前移动速度的快慢,在使用快慢指针时可以让快指针每次沿链表向前移动2，慢指针每次向前一次。<a id="more"></a></h5><h3 id="hello-world-">&emsp;快慢指针的应用</h3><h4 id="hello-world-">&emsp; (一)寻找链表中心</h4>​    原理:快指针的移动速度是慢指针移动速度的两倍，因此当快指针到达表尾时慢指针到达中点，但要分奇偶情况讨论。<p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">while(fast &amp;&amp; slow)&#123;</span><br><span class="line"></span><br><span class="line">​    if(fast-&gt;next &#x3D;&#x3D; NULL)&#123;</span><br><span class="line"></span><br><span class="line">​        return slow-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">​    else if(fast-&gt;next !&#x3D; NULL&amp;&amp;fast-&gt;next-&gt;next &#x3D;&#x3D; NULL)&#123;</span><br><span class="line"></span><br><span class="line">​        return (slow-&gt;data + slow-&gt;next-&gt;data)&#x2F;2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">​    else &#123;</span><br><span class="line"></span><br><span class="line">​        fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">​        slow &#x3D; slow-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hello-world-">&emsp; (二)判断单链表中是否存在环</h4>原理:类似于在操场上跑步，快指针的速度是慢指针移动速度的两倍，让两个指针都从链表头开始遍历，如果快指针最后指向空，则说明并没有环；如果最终快慢指针相等，则说明快指针追了上慢指针存在环。<p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bool JudgeCircle(LNode *head)&#123;</span><br><span class="line"></span><br><span class="line">​    if(head&#x3D;&#x3D;NULL)  return false;</span><br><span class="line"></span><br><span class="line">​    LNode *slow &#x3D; head;</span><br><span class="line"></span><br><span class="line">​    LNode *fast &#x3D; head;</span><br><span class="line"></span><br><span class="line">​    while(fast !&#x3D; NULL &amp;&amp; fast-&gt;next-&gt;next !&#x3D; NULL)&#123;</span><br><span class="line"></span><br><span class="line">​        slow &#x3D; slow-&gt;next;</span><br><span class="line"></span><br><span class="line">​        fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">​        if(slow &#x3D;&#x3D; fast) return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">​    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hello-world-">&emsp; (三)判断两个单链表是否相交</h4>原理:首先利用快慢指针判断链表是否存在环。<p> (1)如果都不存在环，则如果两个单向链表有公共节点，也就是两个链表从某一节点开始，他们的p-&gt;next都指向同一个节点，每个节点只有一个p-&gt;next。因此从第一个公共节点开始，之后它们所有节点都是重合的。因此，首先两个链表各遍历一次，求出两个链表的长度L1、L2，然后可以得到它们的长度差L。然后现在长的链表上遍历L个节点，之后再同步遍历，于是在遍历中，第一个相同的节点就是第一个公共的节点。此时，若两个链表长度分别为M，N,则时间复杂度为O(M+N).</p><p> (2)如果一个存在环，另外一个不存在环，则这两个链表是不可能相交的。</p><p> (3)如果利用快慢指针发现两个链表都存在环，则判断任意一个链表上快慢指针相遇的那个节点，在不在另外一个链表上，如果在，则相交，不在，则不相交。</p><p>第一种情况实现代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void Intersect(LinkList L1, LinkList L2) &#123;</span><br><span class="line">    if (L1 &#x3D;&#x3D; NULL || L2 &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        exit();</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList p &#x3D; L1;</span><br><span class="line">    LinkList q &#x3D; L2;</span><br><span class="line">    int length1 &#x3D; 0;</span><br><span class="line">    int length2 &#x3D; 0;</span><br><span class="line">    int len &#x3D; 0;</span><br><span class="line"></span><br><span class="line">while (p-&gt;next) &#123;</span><br><span class="line">    length1 ++;</span><br><span class="line">    p &#x3D; p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">while (q-&gt;next) &#123;</span><br><span class="line">    length2 ++;</span><br><span class="line">    q &#x3D; q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;p&lt;&lt;q;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;length1&lt;&lt;length2;</span><br><span class="line"></span><br><span class="line">if (p &#x3D;&#x3D; q) &#123;</span><br><span class="line">    cout&lt;&lt;&quot;相交&quot;;</span><br><span class="line">if (length1 &gt; length2) &#123;</span><br><span class="line">    len &#x3D; length1 - length2;</span><br><span class="line">    p &#x3D; L2;</span><br><span class="line">    q &#x3D; L1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    len &#x3D; length2 - length1;</span><br><span class="line">    p &#x3D; L1;</span><br><span class="line">    q &#x3D; L2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (len) &#123;</span><br><span class="line">    q &#x3D; q-&gt;next;</span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br><span class="line">while (p !&#x3D; q) &#123;</span><br><span class="line">    p &#x3D; p-&gt;next;</span><br><span class="line">    q &#x3D; q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;p-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line">    cout&lt;&lt;&quot;不相交&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hello-world-">&emsp;总结</h3>上边的题是我在写LeetCode的时候发现挺有意思的就做了个汇总（当然还有一些其他的题目我想了好久，后边有时间再写），类似的题目还有寻找环的入口以及输出链表中倒数第K个节点。原理其实都差不多所以这两个题我就没有写上来。（参考来源于csdn,博客园,百度百科）]]></content>
      
      
      
        <tags>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国庆前夕之学习历程</title>
      <link href="/2019/09/29/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/09/29/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h6 id="hello-world-">&emsp;  刚学完数据结构的第二章，今天在写“回文链表”时遇到一点问题。<a id="more"></a></h6><hr><p>&emsp;&emsp;我的思路如下：用一个头指针head和一个尾指针tail，头指针向前移动head++，尾指针向后移动tail--,在这个过程中比较他们的值是否相等，如果不相等则返回false；如果相等则两个指针继续移动直至两个指针重合则返回true，说明它是回文链表，但是我编译运行之后并没有得到结果，我在想哪里出了问题，感觉思路没有问题，在看了代码之后我在想能不能用tail--逆向遍历链表呢，如果能逆向遍历那岂不是逆转链表特别容易了吗根本不用迭代和递归了，于是我去向别人求助查阅资料，得知链表中不能进行自增自减运算只能用p=p->next,我是感觉这两种一样，但为什么实际上不一样呢，然后我写了一个程序来验证。<br><br>&emsp;&emsp;程序测试结果表明，p++和p->next确实不一样，链表加1后不一定指向下一个节点，物理位置并没有连着。由于当时想到了线性表合并中两个指针的自增操作，把它带进了链表中，实际上顺序表是顺序存储结构，但链表并不是，所以p++并不等于p->next。<br></p><p>​       接着，说一下这几天写程序的感想。</p><p>​     《数据结构与算法》这本书非常重要，我们老师在给我们上课时讲到大二一定要过“编程关”，并建议我们每天花上一两个小时写程序。虽然我们是计算机科学与技术专业，编程能力的要求可能也没有软件工程要高，但是我觉得在学习中要以软件工程的标准来要求自己，有时间就去写写程序，量变达到质变，能力太重要啦。另外一点小小感悟，没事的时候就爱随便翻翻网站，今天逛了ccpc网络选拔赛和LeetCode的周赛排名榜，全国排名或者世界排名靠前的人基本上都是清华北大以及一些其他实力较强的985院校，像我所在的普通一本院校连报名的人都很少更别说获奖了，其实绝大多数人给我的感觉都不知道自己真正想要的是什么。可能差距从高考那一天就已经开始了，有时也会感悟，985院校真的会给你提供一个完全不一样的更高的平台。我也想好好努力，以考研为跳板去一个更高的平台，遇见更优秀的你和我！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活琐事</title>
      <link href="/2019/09/12/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
      <url>/2019/09/12/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="hello-world-">&emsp;生活碎片-1<a id="more"></a></h5><hr><p>&emsp;&emsp;最近喜欢上一句话“I love three things in the world,the sun,the moon and you，the sun for the day,the moon for the night,and you forever",我什么时候会对一个人说这样的话呢。<br><br>&emsp;&emsp;心情复杂，烦恼又急切，焦虑又难过。明明是18岁最好的年纪，总是感觉达不到自己的期望值。这学期java，数据结构，python，四种语言混着用还是挺怕自己有些地方混淆，虽然这学期课也挺少的但是事情是真的多，C语言过编程关，java，python都得一起学以及12月份的英语六级。有时候我会想，我为什么大学不选个师范院校的英语专业或者就听我爸学医以后就安安逸逸的过自己一生得了，非得执着于计算机，可能我骨子里就是这样不安定，爱挑战一些有难度，新鲜的事物。每完成一道编程大题我就有一种做完一道奥数题的感觉，这种成就感和快乐让我很享受。还有一件最最最令人难过的事情，刚刚称了一下体重，真的胖了好多！！我不能再这样吃下去了！从明天开始，我要让这些不愉快都留在2019年，以一个更好的姿态迎接2020年！迎接19岁更好的自己！生活还是需要很多仪式感的。给我冲！！！（前面说完这些话，心情真的好多了）哦对了，明天中秋节我先祝自己中秋节快乐，而且我买了星光音乐节的票有赵雷还有隔壁老樊等等等这些民谣歌手，虽然我表面看起来是个喜欢技术的人但我骨子里应该算是个文艺的人。今天就说到这吧，晚安！<br></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The first article</title>
      <link href="/2019/08/27/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/08/27/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;前几天在网上查资料的时候，看见别人的精美的博客页面，我寻思我可不可以也做一个自己的博客。说时迟，那时快，决定之后我立马就动手做了。<br><br>&emsp;&emsp;在CSDN，简书，博客园等的帮助下，我从在腾讯云上购买域名到注册github绑定域名，创建仓库，配置SSH key，修改主题，上传到github上等。这个过程中也遇到了一些问题（我也是算是小白中的小白了，这些东西都是第一次接触），多亏了互联网的强大，我才辛辛苦苦把我的个人网站搭建起来。虽然有一丝简陋，以后学习更多的新知识再改吧，拥有自己一小块地的感觉太好了（我可以为所欲为）。<br></p><p>&emsp;&emsp;这个博客以后主要是用来记录和总结我的学习以及生活，路漫漫其修远兮，吾将上下而求索！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
